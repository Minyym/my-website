## 观察者模式

- 发布订阅又称观察者模式，它定义对象之间的1对N的依赖关系，当其中一个对象发生变化时，所有依赖于它的对象都会得到通知。
- 发布订阅模式经常出现在我们的工作场景中，如：当你给DOM绑定一个事件就已经使用了发布订阅模式，通过订阅DOM上的click事件，当被点击时会向订阅者发布消息。

#### 优点

- 观察者和被观察者它们之间是抽象耦合的。并且建立了触发机制。

#### 缺点

- 当订阅者比较多的时候，同时通知所有的订阅者可能会造成性能问题。
- 在订阅者和订阅目标之间如果循环引用执行，会导致崩溃。
- 发布订阅模式没有办法提供给订阅者所订阅的目标它是怎么变化的，仅仅只知道它变化了。

#### 例子

- 比喻前段时间的冬奥会，项目还没有开始的时候可以提前预定，等到项目快开始的时，APP会提前给我们发送通知即将开始的项目，而没到时间的不通知，另外在项目还没有开始的时候，可以取消订阅避免接受到通知。

  ```JS
  class Subject {
    constructor(){
      this.observers = {}
      this.key = ''
    }
    add(observer){
      const key = observer.project
      if (!this.observers[key]) {
        this.observers[key] = []
      }
      this.observers[key].push(observer)
    }
    remove(observer){
      const _observers = this.observers[observer.project]
      console.log(_observers,11)
      if(_observers.length){
        _observers.forEach((item,index)=>{
          if(item === observer){
            _observers.splice(index,1)
          }
        })
      }
    }
    setObserver(subject){
      this.key = subject
      this.notifyAllObservers()
    }
    notifyAllObservers(){
      this.observers[this.key].forEach((item,index)=>{
        item.update()
      })
    }
  }
  
  class Observer {
    constructor(project,name) {
      this.project = project
      this.name = name
    }
    update() {
      console.log(`尊敬的:${this.name} 你预约的项目：【${this.project}】 马上开始了`)
    }
  }
  
  const subject = new Subject()
  const xiaoming = new Observer('滑雪','xiaoming')
  const A = new Observer('大跳台','A')
  const B = new Observer('大跳台','B')
  const C = new Observer('大跳台','C')
  subject.add(xiaoming)
  subject.add(A)
  subject.add(B)
  subject.add(C)
  subject.remove(B) // 取消订阅
  subject.setObserver('大跳台')
  /** 执行结果
   * 尊敬的:A 你预约的项目：【大跳台】 马上开始了
   * 尊敬的:C 你预约的项目：【大跳台】 马上开始了
   */
  ```

  


