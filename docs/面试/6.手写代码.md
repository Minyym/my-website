# 手写XXX

## 手写iterator

```JS
Array.prototype.myIterator = function () {
    let index = 0;
    const _this = this; //保存当前的this指向，用来在其他地方使用
    return {
        next: function () {
            if (index < _this.length) {
                return {
                    value: _this[index++],
                    done: false
                }
            } else {
                return {
                    value: undefined,
                    done: true
                }
            }
        }
    }
}
```

## 使用extends书写一个继承

```JS
class Person {
    constructor(name) {
        this.name = name;
    }
    eat() {}
}
class Student extends Person {
    constructor(name, age) {
        super(name);
        this.age = age;
    }
    study() {}
}
```

## new构造函数

```JS
 //手写new
function writeNew(constr) {
    //创建一个对象
    var o = {};
    //把构造函数的this指向当前的对象o  并且向调用构造函数并传入参数 返回值就是A函数的返回值
    var result = constr.apply(o, Array.prototype.slice.call(arguments, 1));
    //把自定义对象的隐式原型指向构造函数的显式原型
    o.__proto__ = constr.prototype;
    //判断构造函数的返回值是基础值 还是对象
    var isObj = typeof result === 'object' && typeof result != null;
    var isFun = typeof result === 'function';
    //根据构造函数的返回值 设置new的返回值
    return (isObj || isFun) ? result : o;
}
```



## 封装一个axios

```JS
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button id="btn01">GET</button>
    <button id="btn02">POST</button>
    <script>
        /* 
            封装一个axios
                1.参数:是一个对象
                2.返回值是一个promise对象
                3.先创建一个xhr对象
                    3.1处理method大小写的问题
                4.绑定onreadystatechange事件
                    2.1 在请求数据成功时和xhr.readyState ===4 时返回成功的promise对象
                    2.2 在xhr.readyState ===4和没有请求数据成功时，返回一个失败的promise对象G
                5.设置请求信息
                    5.1 如果传递了params，对它进行处理，处理成？name = "123"&age =18 的形式，拼接在url地址的后面
                6.发送请求
                    6.1 判断是不是POST PUT PATCH方式请求
                    6.2将传递的数据转换为JSON的格式
         */

        function myAxios({ method, url, data, params }) {

            return new Promise((resolve, reject) => {
                // 1.先创建一个xhr对象
                const xhr = new XMLHttpRequest();
                // 处理method的大小写的问题
                method = method.toUpperCase();
                // 2.绑定onreadystatechange事件
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (199 < xhr.status < 300) {
                            const response = {
                                request: xhr,
                                status: xhr.status,
                                data: JSON.parse(xhr.responseText),
                            };
                            resolve(response);
                        } else {
                            reject("err")
                        }
                    }
                }
                // 如果params也传递进来，对它进行处理,params是一个对象，要将他转换成  ?name="xiaoli"&age=18的格式，拼接在地址上，不需要判断是什么请求
                let queryString = ""
                if (params) {
                    queryString = Object.keys(params).reduce((p, i) => {
                        return p + `${i}=${params[i]}&`
                    }, '?').slice(0, -1)
                }
                // 3.设置请求信息
                xhr.open(method, url + queryString)
                // 判断是什么是什么请求方式,是POST请求的话，要处理数据，将数据转换成JSON字符串的形式
                let body = ""
                if ((method === "POST" || method === "PUT" || method === "PATCH") && data) {
                    xhr.setRequestHeader("content-type", "application/json")
                    body = JSON.stringify(data)
                }
                // 4.发送请求
                xhr.send(body)
            })
        }
        const btn01 = document.getElementById('btn01');
        const btn02 = document.getElementById('btn02');
        btn01.onclick = function () {
            myAxios({
                method: "GET",
                url: "http://localhost:3000/comments"
            }).then((value) => {
                console.log(value);
            })
        }
        btn02.onclick = function () {
            myAxios({
                method: "POST",
                url: "http://localhost:3000/comments",
                data: {
                    body: "wys",
                    postId: 2,
                }
            }).then((value) => {
                console.log(value);
            })
        }

    </script>
</body>

</html>
```

## 1.Promise构造函数

```JS
  function myPromise(exec) {
    const that = this;
    that._status = "pending";
    that._value = undefined;
    // d定义一个容器用来存放，then方法的回调,当promise对象中调用了resolve和reject方法后，then方法的回调函数才会调用，并且异步调用
    that._callBack = {};
    // 设置resolve函数
    function resolve(value) {
      // 状态值只会该改变一次，这就意味着，状态只能是从pending开始的
      if (that._status !== "pending") return;
      that._status = "resolved";
      that._value = value;
      setTimeout(() => {
        that._callBack.onResolved?.(value);
      });
    }

    function reject(reason) {
      // 状态值只会该改变一次，这就意味着，状态只能是从pending开始的
      if (that._status !== "pending") return;
      that._status = "rejected";
      that._value = reason;
      setTimeout(() => {
        that._callBack.onRejected?.(reason);
      });
    }
    exec(resolve, reject);
  }
```

## 2.then

```JS
  myPromise.prototype.then = function (onResolved, onRejected) {
    //要将正确的传递下去
    onResolved =
      typeof onResolved === "function" ? onResolved : (value) => value;
    //将错误的传递下去
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (reason) => {
            throw reason;
          };
    const that = this;
    // 链式调用，返回Promise对象
    // 返回的Promise对象的状态，是由then方法的回调的函数的返回值决定的
    return new myPromise((resolve, reject) => {
      // 又套了一层函数，是为了获取到then方法回调的返回值
      that._callBack.onResolved = function (value) {
        try {
          const res = onResolved(value);
          if (res instanceof myPromise) {
            // then方法的回调的返回值是一个Promise对象，那么then方法的返回值是和回调的Promise是相同的，失败调失败，成功调成功
            res.then(resolve, reject);
          } else {
            // 其余返回成功的  res是回调的返回值，这里res的值可能是11
            resolve(res);
          }
        } catch (e) {
          reject(e);
        }
      };
      that._callBack.onRejected = function (reason) {
        try {
          const res = onRejected(reason);
          if (res instanceof myPromise) {
            // then方法的回调的返回值是一个Promise对象，那么then方法的返回值是和回调的Promise是相同的，失败调失败，成功调成功
            res.then(resolve, reject);
          } else {
            // 其余返回成功的  res是回调的返回值，这里res的值可能是11
            resolve(res);
          }
        } catch (e) {
          reject(e);
        }
      };
    });
  };
```

## 3.catch

```JS
 myPromise.prototype.catch = function (onRejected) {
    return this.then(undefined, onRejected);
  };
```

## 4.resolve

```JS
 myPromise.resolve = function (value) {
    if (value instanceof myPromise) {
      return value;
    } else {
      return new myPromise((resolve) => resolve());
    }
  };
```

## 5.reject

```JS
myPromise.reject = function (reason) {
    return new myPromise((resolve, reject) => {
      reject(reason);
    });
  };
```

## 6.all

```JS
  myPromise.all = function (arr) {
    return new myPromise((resolve, reject) => {
      const valueArr = [];
      let count = 0;
      arr.forEach((item, index) => {
        if (item instanceof myPromise) {
          item.then((value) => {
            returnValue(index, value);
          }, reject);
        } else {
          returnValue(index, item);
        }
      });
      function returnValue(index, value) {
        valueArr[index] = value;
        count++;
        if (arr.length === count) {
          resolve(valueArr);
        }
      }
    });
  };
```

## 7allSettled

```JS
 myPromise.allSettled = function (arr) {
    const valueArr = [];
    let count = 0;
    return new myPromise((resolve, reject) => {
      arr.forEach((item, index) => {
        if (item instanceof myPromise) {
          item.then(
            (value) => {
              count++;
              arr[index] = {
                status: "resolved",
                value,
              };
              if (count === arr.length) {
                resolve(arr);
              }
            },
            (reason) => {
              count++;
              arr[index] = {
                status: "resolved",
                reason,
              };
              if (count === arr.length) {
                resolve(arr);
              }
            }
          );
        } else {
          count++;
          arr[index] = {
            status: "rejected",
            value:item,
          };
          if (count === arr.length) {
            resolve(arr);
          }
        }
      });
    });
  };
```



## 





# 代码操作

## 已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”

```JS
function combo(msg){
    var arr=msg.split("-");
    for(var i=1;i<arr.length;i++){
     arr[i]=arr[i].charAt(0).toUpperCase()+arr[i]
.substr(1,arr[i].length-1);
    }
    msg=arr.join("");
    return msg;
}
// charAt返回指定下标的字符串 substr截取字符串
```

## 输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26

```JS
var d = new Date();
// 获取年，getFullYear()返回4位的数字
var year = d.getFullYear();
// 获取月，月份比较特殊，0是1月，11是12月
var month = d.getMonth() + 1;
获取年份 getFullYear
获取月份 getMonth
获取日 getDate
获取小时 getHours
获取分钟 getMinutes
获取秒 getSeconds
获取毫秒 getMilliseconds
获取星期 getDay
```

## 将字符串”<tr><td>{$id}</td><td>{$name}</td></tr>”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）

```JS
"<tr><td>{$id}</td><td>{$id}_{$name}</td></tr>".replace(/{\$id}/g, '10').replace(/{\$name}/g, 'Tony')
```

## 把两个数组合并，并删除第二个元素

```JS
var array1 = ['a','b','c'];
var bArray = ['d','e','f'];
var cArray = array1.concat(bArray);
cArray.splice(1,1);
```

## item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}。

```JS
const str = "http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e";

const attr = str.split("?")[1].split("&");
const obj = attr.reduce((p, c) => {
  const [key, value] = c.split("=");
  console.log(key, value);
  p[key] = value;
  return p;
}, {});
console.log(obj);
```

## 判断一个字符串中出现次数最多的字符，统计这个次数

```JS
var str = "asdfssaaasasasasaa";
var obj = {};
for (var i = 0; i < str.length; i++) {
  // 判断对象中是否存在单个字符，不存在就添加上，值是1
  if (!obj[str.charAt(i)]) {
    obj[str.charAt(i)] = 1;
  } else {
    // 如果存在，就加加
    obj[str.charAt(i)]++;
  }
}
// 用来保存次数
var value = 0;
// 用来保存是谁次数最多
var key = 0;
// 遍历对象拿到数值最大的
for (var i in obj) {
  // console.log(i);
  if (obj[i] > value) {
    value = obj[i];
    key = i;
  }
}
console.log(max, key);
```

## 字符串反转，如将 '12345678' 变成 '87654321

```JS
//思路：先将字符串转换为数组 split()，利用数组的反序函数 reverse()颠倒数组，再利用 jion() 转换为字符串
var str = '12345678';
str = str.split('').reverse().join('');
```

## 数字反转

```JS
function numReverse(s) {
  // 定义我最终要输出的数字
  var result = 0;
  while (s) {
    // 每次得到各位上的数字
    const r = s % 10;
    // 因为是反转，位置要提升的
    result = result * 10 + r;
    // 去掉个位上的数字
    s = (s - r) / 10;
  }
  return result;
}
```

## 冒泡排序

```JS
const arr = [1, 2, 8, 4, 3, 5, 7];
for (var i = 1; i < arr.length; i++) {
  for (var j = 0; j < arr.length - i; j++) {
    if (arr[j] > arr[j + 1]) {
      var temp;
      temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
    }
  }
}
```

## 反转数组

```JS
// 方式1
const arr = [1, 2, 3];
const newArr = [];
for (var i = arr.length - 1; i >= 0; i--) {
  newArr[newArr.length] = arr[i];
}
console.log(newArr);
// 方式二
for (var i = 0; i < arr.length / 2; i++) {
  var temp = arr[i];
  arr[i] = arr[arr.length - 1 - i];
  arr[arr.length - 1 - i] = temp;
}
console.log(arr);
```

## 去重

```JS
 function qc(arr) {
    return arr.reduce((p, v) => (p.includes(v) ? p : [...p, v]), [])
  }
 const re = qc(arr);
 console.log(re);
```

```JS
Array.prototype.unique = function () {
    return this.filter((item, index) => this.indexOf(item) === index);
 }
```

## 实现1px像素的边框

#### 方法一

使用媒查询：

```css
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo{
        border: 0.5px solid black;
    }
}
```

#### 方法二

​	根据dpr扩大布局视口，例如dpr为n则布局视口改为原来的n倍，则元素尺寸均变为原来的n分之一，为了保证元素尺寸比例不变，扩大根字体为原来的n倍，但整个过程中边框一直用px作为单位，不用rem。

1. rem 页面布局

```js
function mobile (){
   document.documentElement.style.fontSize = (document.documentElement.clientWidth * 100)/375 + 'px'
}
mobile()
window.onresize = mobile
```

2. 元素的边框设置为 1px

3. 通过 viewport 中的 initial-scale 将布局视口扩大n倍，这样页面元素就比原来缩小了n倍

```js
var viewport = document.querySelector('meta[name=viewport]')
var scale = 1 / window.devicePixelRatio
viewport.setAttribute('content', 'width=device-width,initial-scale=' + scale);
```

4. 重新设置根元素字体

```js
var fontSize = parseInt(document.documentElement.style.fontSize);
document.documentElement.style.fontSize = fontSize * window.devicePixelRatio + 'px'
```

## CSS画一个三角形

```JS
1. 给边框宽度，大一些
2. 让元素的内容宽度是0
3. 就有了四个三角形，设置其中三个为透明
.box {
    border-top: 20px solid transparent;
    border-bottom: 20px solid transparent;
    border-left: 20px solid #856;
    border-right: 20px solid transparent6;
    width: 0;
    height: 0;
  }
<div class="box"></div>
```

## 下面输出什么

```JS
function Foo() {
  getName = function () {//Foo调用是会给全局添加一个getName
    console.log(1);
  };
  return this;
}
Foo.getName = function () {//给Foo添加一个静态方法
  console.log(2);
};
Foo.prototype.getName = function () {
  console.log(3);
};
var getName = function () {//覆盖getName函数
  console.log(4);
};
function getName() {//变量提升了，被var定义的getName给覆盖掉了
  console.log(5);
}

Foo.getName();//2
getName();//4
Foo().getName();//1  （Foo()）.getName();-》window.getName  Foo调用了，里面的getName方法，没有var所以是是全局的，将全局的getName方法修改为了1
getName();//1  在调用时，就是1
new Foo.getName();// 2  new (Foo.getName();)
new Foo().getName();//3 (new Foo()).getName() 实例对向
new new Foo().getName();//3 new （（1new Foo()）.getName()2）
//点的运算符优先级最高
```

## 节流

```JS
函数的节流(throttle)与防抖(debounce)
     作用：为了节约函数的性能（让函数调用次数更少）
     节流(throttle)：让函数在单位时间内只调用一次，第一次调用生效
     应用场景：发送验证码按钮
     
<div id="box"></div>
    <script>
        const oBox = document.querySelector("#box");
        //功能函数
        function move(e) {
            console.log(Date.now());
            console.log(this); //应该是指向oBox
            console.log(e) //
        }
        const result = throttle(move, 200);
        //当box事件触发的时候 会走看门狗
        oBox.onmousemove = result;
        //高阶函数
        //封装一个节流函数,参数:需要节流的功能函数  是每次功能函数调用所间隔的时间
        function throttle(fn, time) {
            //进来以后判断最新的时间和上一次访问的时间 间隔是否有200ms  
            //如果有 则执行move函数  否则直接return

            //第一次进来没有上一次的时间,并且第一次一定是要执行的
            //所以直接给第一个进来设置一个上一次的默认时间是0
            let lastTime = 0;
            return function () {
                //获取当前进入的时间
                let nowTime = Date.now();
                //进行判断，如果小于就直接返回出去
                if (nowTime - lastTime < time) {
                    return;
                }
                //如果时间超出 则直接调用fn
                //当前return的函数this指向是box 所以需要把fn的this指向当前的this
                //当前的return的才是真正的事件函数,所以当前return的函数拥有event,但是fn没有
                //需要把当前return的函数的参数 给到fn上
                fn.call(this, arguments[0]);
                //把lastTime更新一下 方便下次判断
                lastTime = nowTime;
            }
        }
```

## 防抖

```JS
<div id="box"></div>
    <script>
        const oBox = document.querySelector("#box");

        //功能函数
        function move(e) {
            console.log(Date.now());
            console.log(this); //应该是指向oBox
            console.log(e) //
        }

        const result = debounce(move, 200);

        //当我最后一次移动完成之后 200毫秒后再执行
        oBox.onmousemove = result;

        function debounce(fn, time) {
            let timerID = null;
            return function () {
                //每次move一执行 就要重新触发 重新计时 所以需要清除计时器
                clearTimeout(timerID);
                const arg = arguments;
                //重新设置时间
                timerID = setTimeout(() => {
                    fn.call(this, arg[0]);
                }, 200)
            }
        }
    </script>
```

## 快排

```JS
function quickSort(arr) {
    //如果数组的长度只剩下一个  就直接返回这个数组就行了
    if (arr.length <= 1) {
        return arr;
    }
    //取出基准值(任意值都可以)
    const baseValueIndex = Math.floor(arr.length / 2);
    //把原数组中的基准值删除掉,arr直接变成一个去除基准值的新数组,并且返回了一个删除元素的数组
    const baseValue = arr.splice(baseValueIndex, 1)[0];
    const left = [],
        right = [];

    arr.forEach((item, index) => {
        if (item < baseValue) {
            left.push(item);
        } else {
            right.push(item);
        }
    })
    //递归并合并
    return quickSort(left).concat(baseValue, quickSort(right))
}
const re = quickSort([1, 3, 5, 2, 11, 6, 4, 9, 7, 0]);
console.log(re);
```

##  封装一个绑带事件监听的函数(有难度)

```js
/* 
绑定事件监听的通用函数(不带委托)
*/
function bindEvent1 (ele, type, fn) {
  ele.addEventListener(type, fn)
}

/* 
绑定事件监听的通用函数(带委托)
*/
function bindEvent2(ele, type, fn, selector) {

  ele.addEventListener(type, event => {
    // 得到发生事件的目标
    const target = event.target
    if (selector) {
      // 如果元素被指定的选择器字符串选择, 返回true; 否则返回false。
      if (target.matches(selector)) {
        // 委托绑定调用
        fn.call(target, event)
      } 
    } else {
      // 普通绑定调用
      fn.call(ele, event)
      // fn(event) // this不对
    }
  })
}


<ul>
   <span>
    <li>
    <li>
</ul>
    
bindEvent2(ul, 'click', (event) => {}, 'li')
bindEvent2(ul, 'click', (event) => {})
```

## 函数的call() / apply() / bind()

```js
/* 
自定义函数对象的call方法
*/
function call (fn, obj, ...args) {
  // 如果传入的是null/undefined, this指定为window
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象
  obj.tempFn = fn
  // 通过obj调用这个方法
  const result = obj.tempFn(...args)
  // 删除新添加的方法
  delete obj.tempFn
  // 返回函数调用的结果
  return result
}

/* 
自定义函数对象的apply方法
*/
function apply (fn, obj, args) {
  // 如果传入的是null/undefined, this指定为window
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  // 给obj添加一个方法: 属性名任意, 属性值必须当前调用call的函数对象
  obj.tempFn = fn
  // 通过obj调用这个方法
  const result = obj.tempFn(...args)
  // 删除新添加的方法
  delete obj.tempFn
  // 返回函数调用的结果
  return result
}

/* 
  自定义函数对象的bind方法
  重要技术:
    高阶函数
    闭包
    call()
    三点运算符
*/
function bind (fn, obj, ...args) {
  if (obj===null || obj===undefined) {
    obj = obj || window
  }
  
  return function (...args2) {
    return call(fn, obj, ...args, ...args2)
  }
}
```



## 函数的节流(throttle)与防抖(debounce)

```js
/* 
实现函数节流的函数
*/

function throttle(callback, delay) {
  let start = 0 // 必须保存第一次点击立即调用
  return function (event) { // 事件回调函数
    // this是发生事件的dom元素
    console.log('throttle 事件')
    const current = Date.now()
    if (current - start > delay) { // 从第2次点击开始, 需要间隔时间超过delay
      callback.call(this, event)
      // 将当前时间指定为start, ==> 为后面的比较做准备
      start = current
    }
  }
}

/* 
实现函数防抖的函数
*/
function debounce(callback, delay) {
  return function (event) {
    console.log('debounce 事件...')
    
    // 清除待执行的定时器任务
    if (callback.timeoutId) {
      clearTimeout(callback.timeoutId)
    }
    // 每隔delay的时间, 启动一个新的延迟定时器, 去准备调用callback
    callback.timeoutId = setTimeout(() => {
      callback.call(this, event)
      // 如果定时器回调执行了, 删除标记
      delete callback.timeoutId
    }, delay)
  }
}
```



## 数组去重(unique)

```js
/*
方法1: 利用forEach()和indexOf()
  说明: 本质是双重遍历, 效率差些
*/
function unique1 (array) {
  const arr = []
  array.forEach(item => {
    if (arr.indexOf(item)===-1) { // 内部在遍历判断出来的
      arr.push(item)
    }
  })
  return arr
}

/*
方法2: 利用forEach() + 对象容器
  说明: 只需一重遍历, 效率高些
*/
function unique2 (array) {
  const arr = []
  const obj = {}
  array.forEach(item => {
    if (!obj.hasOwnProperty(item)) {// 不用遍历就能判断出是否已经有了
      obj[item] = true
      arr.push(item)
    }
  })
  return arr
}

/*
方法3: 利用ES6语法
    1). from + Set
    2). ... + Set
    说明: 编码简洁
*/
function unique3 (array) {
  // return Array.from(new Set(array))
  return [...new Set(array)]
}
```



## 数组扁平化(flatten) 

```js
/* 
数组扁平化: 取出嵌套数组(多维)中的所有元素放到一个新数组(一维)中
  如: [1, [3, [2, 4]]]  ==>  [1, 3, 2, 4]
*/

/*
方法一: 递归 + reduce() + concat()
*/
function flatten1 (array) {

  return array.reduce((pre, item) => {
    if (Array.isArray(item) && item.some((cItem => Array.isArray(cItem)))) {
      return pre.concat(flatten1(item))
    } else {
      return pre.concat(item)
    }
  }, [])
}

/*
方法二: ... + some() + concat()
*/
function flatten2 (array) {

  let arr = [].concat(...array)
  while (arr.some(item => Array.isArray(item))) {
    arr = [].concat(...arr)
  }
  return arr
}
```



## 深拷贝

```js
/* 
深度克隆
1). 大众乞丐版
    问题1: 函数属性会丢失
    问题2: 循环引用会出错
2). 面试基础版本
    解决问题1: 函数属性还没丢失
3). 面试加强版本
    解决问题2: 循环引用正常
4). 面试加强版本2(优化遍历性能)
    数组: while | for | forEach() 优于 for-in | keys()&forEach() 
    对象: for-in 与 keys()&forEach() 差不多
*/

const obj = {
    a: {
        
    },
    b: [],
    fn: function (){}
}
obj.a.c = obj.b
obj.b[0] = obj.a
/* 
1). 大众乞丐版
  问题1: 函数属性会丢失
  问题2: 循环引用会出错
*/
export function deepClone1(target) {
  return JSON.parse(JSON.stringify(target))
}

/* 
获取数据的类型字符串名
*/
function getType(data) {
  return Object.prototype.toString.call(data).slice(8, -1)  // -1代表最后一位
    // [object Array]  ===> Array  [object Object] ==> Object
}

/*
2). 面试基础版本
  解决问题1: 函数属性还没丢失
*/
function deepClone2(target) {
  const type = getType(target)

  if (type==='Object' || type==='Array') {
    const cloneTarget = type === 'Array' ? [] : {}
    for (const key in target) {
      if (target.hasOwnProperty(key)) {
        cloneTarget[key] = deepClone2(target[key])
      }
    }
    return cloneTarget
  } else {
    return target
  }
}

/* 
3). 面试加强版本
  解决问题2: 循环引用正常
*/
function deepClone3(target, map = new Map()) {
  const type = getType(target)
  if (type==='Object' || type==='Array') {
     // 从map容器取对应的clone对象
    let cloneTarget = map.get(target)
    // 如果有, 直接返回这个clone对象
    if (cloneTarget) {
      return cloneTarget
    }
    cloneTarget = type==='Array' ? [] : {}
    // 将clone产生的对象保存到map容器
    map.set(target, cloneTarget)
    for (const key in target) {
      if (target.hasOwnProperty(key)) {
        cloneTarget[key] = deepClone3(target[key], map)
      }
    }
    return cloneTarget
  } else {
    return target
  }
}

/* 
4). 面试加强版本2(优化遍历性能)
    数组: while | for | forEach() 优于 for-in | keys()&forEach() 
    对象: for-in 与 keys()&forEach() 差不多
*/
function deepClone4(target, map = new Map()) {
  const type = getType(target)
  if (type==='Object' || type==='Array') {
    let cloneTarget = map.get(target)
    if (cloneTarget) {
      return cloneTarget
    }

    if (type==='Array') {
      cloneTarget = []
      map.set(target, cloneTarget)
      target.forEach((item, index) => {
        cloneTarget[index] = deepClone4(item, map)
      })
    } else {
      cloneTarget = {}
      map.set(target, cloneTarget)
      Object.keys(target).forEach(key => {
        cloneTarget[key] = deepClone4(target[key], map)
      })
    }

    return cloneTarget
  } else {
    return target
  }
}
```



## 自定义new和instanceof工具函数

```js
/* 
自定义new工具函数
  语法: newInstance(Fn, ...args)
  功能: 创建Fn构造函数的实例对象
  实现: 创建空对象obj, 调用Fn指定this为obj, 返回obj
*/
function newInstance(Fn, ...args) {
  // 创建一个新的对象
  const obj = {}
  // 执行构造函数
  const result = Fn.apply(obj, args) // 相当于: obj.Fn()
  // 如果构造函数执行的结果是对象, 返回这个对象
  if (result instanceof Object) {
    return result
  }
  // 如果不是, 返回新创建的对象
  obj.__proto__.constructor = Fn // 让原型对象的构造器属性指向Fn
  
  return obj
}

/* 
自定义instanceof工具函数: 
  语法: myInstanceOf(obj, Type)
  功能: 判断obj是否是Type类型的实例
  实现: Type的原型对象是否是obj的原型链上的某个对象, 如果是返回true, 否则返回false
*/
function myInstanceOf(obj, Type) {
  // 得到原型对象
  let protoObj = obj.__proto__

  // 只要原型对象存在
  while(protoObj) {
    // 如果原型对象是Type的原型对象, 返回true
    if (protoObj === Type.prototype) {
      return true
    }
    // 指定原型对象的原型对象
    protoObj = protoObj.__proto__
  }

  return false
}
```

## 字符串处理

```js
/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/

/* 
1. 字符串倒序: reverseString(str)  生成一个倒序的字符串
*/
function reverseString(str) {
  // return str.split('').reverse().join('')
  // return [...str].reverse().join('')
  return Array.from(str).reverse().join('')
}

/* 
2. 字符串是否是回文: palindrome(str) 如果给定的字符串是回文，则返回 true ；否则返回 false
*/
function palindrome(str) {
  return str === reverseString(str)
}

/* 
3. 截取字符串: truncate(str, num) 如果字符串的长度超过了num, 截取前面num长度部分, 并以...结束
*/
function truncate(str, num) {
  return str.length > num ? str.slice(0, num) + '...' : str
}
```



## 简单排序: 冒泡 / 选择 / 插入

```js
/* 
冒泡排序的方法
*/
function bubbleSort (array) {
  // 1.获取数组的长度
  var length = array.length;

  // 2.反向循环, 因此次数越来越少
  for (var i = length - 1; i >= 0; i--) {
    // 3.根据i的次数, 比较循环到i位置
    for (var j = 0; j < i; j++) {
      // 4.如果j位置比j+1位置的数据大, 那么就交换
      if (array[j] > array[j + 1]) {
        // 交换
        // const temp = array[j+1]
        // array[j+1] = array[j]
        // array[j] = temp
        [array[j + 1], array[j]] = [array[j], array[j + 1]];
      }
    }
  }

  return arr;
}

/* 
选择排序的方法
*/
function selectSort (array) {
  // 1.获取数组的长度
  var length = array.length

  // 2.外层循环: 从0位置开始取出数据, 直到length-2位置
  for (var i = 0; i < length - 1; i++) {
    // 3.内层循环: 从i+1位置开始, 和后面的内容比较
    var min = i
    for (var j = min + 1; j < length; j++) {
      // 4.如果i位置的数据大于j位置的数据, 记录最小的位置
      if (array[min] > array[j]) {
        min = j
      }
    }
    if (min !== i) {
      // 交换
      [array[min], array[i]] = [array[i], array[min]];
    }
  }

  return arr;
}

/* 
插入排序的方法
*/
function insertSort (array) {
  // 1.获取数组的长度
  var length = array.length

  // 2.外层循环: 外层循环是从1位置开始, 依次遍历到最后
  for (var i = 1; i < length; i++) {
    // 3.记录选出的元素, 放在变量temp中
    var j = i
    var temp = array[i]

    // 4.内层循环: 内层循环不确定循环的次数, 最好使用while循环
    while (j > 0 && array[j - 1] > temp) {
      array[j] = array[j - 1]
      j--
    }

    // 5.将选出的j位置, 放入temp元素
    array[j] = temp
  }

  return array
}
```



# 代码输出

```JS
//4  1  3  6  8  2  7  5
async function async1() {
    console.log('1');
    await async2();// 这里的await，就值一直等，等其他的同步的执行完毕在执行，它下面的2
    console.log('2')
}

async function async2() {
    console.log('3')
}

console.log('4');      
setTimeout(() => {
    console.log('5')
}, 0);

async1();

new Promise((resolve) => {
    console.log('6');
    resolve()
}).then(() => {
    console.log('7')
});
console.log('8')
```

# webpack

## 简单介绍一下webpack

* 什么是webpack
  * Webpack是一个模块打包器(bundler)。
  * 在Webpack看来, 前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理
  * 它将根据模块的依赖关系进行静态分析，生成对应的静态资源
* 五个核心概念
  * Entry：入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。
  * Output：output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。
  * Loader：loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只能解析 JavaScript）。
  * Plugins：插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。一般是实现一些新功能的扩展,
  * Mode：模式，有生产模式production和开发模式development
* 理解Loader
  * Webpack 本身只能加载JS/JSON模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 进行转换/加载
  * Loader 本身也是运行在 node.js 环境中的 JavaScript 模块
  * 它本身是一个函数，接受源文件作为参数，返回转换的结果
  * loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。
* 理解Plugins
  * 插件可以完成一些loader不能完成的功能。
  * 插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。
* 配置文件(默认)
  * webpack.config.js : 是一个node模块，返回一个 json 格式的配置信息对象

# 移动端

## 移动端适配

**为什么要做适配？**
			由于移动端设备的屏幕尺寸大小不一，会出现：同一个元素，在两个不同的手机上显示效果不一样（比例不同）。要想让同一个元素在不同设备上，显示效果一样，就需要适配，**无论采用何种适配方式，中心原则永远是：**<span style="color:#ee0b41">**等比**</span>！

主流的适配方式有三种：

* viewport 适配
* rem 适配（主流方式，几乎完美适配）
* vw、vh适配

### 1.viewport 适配

- 方法：拿到设计稿之后，设置布局视口宽度为设计稿宽度，然后直接按照设计稿给宽高进行布局即可。

- ```JS
  <meta name="viewport" content="width=设计稿的宽度" />
  ```

- 优点：不用复杂的计算，直接使用图稿上标注的px值

- 缺点：

  - 有些不希望被适配的东西，例如边框，也被适配了，导致比设计稿大的设备上边框太粗。
  - 图片失真
  - 不能使用完整的meta标签，会导致在某些安卓手机上有兼容性问题。

- 一般适用于：计图稿宽度 < 375

### <span style="color:#ee0b41">2.rem适配</span>（在理想视口的基础上实现，让元素的宽度实现动态变化）

#### em 和 rem

em 和 rem 都是 css 中的长度单位。而且两个都是相对长度单位，不过两个有点区别

* em 相对的是父级元素的字体大小
* rem 相对的是根元素的字体大小

rem适配的原理：编写样式时统一使用rem为单位，在不同设备上动态调整根字体大小

#### 具体方案：

##### 方案一：

淘宝、百度的移动端页面用的此方案

1. 设置完美视口
2. <span style="color:#ee0b41">通过js设置根字体大小 = **( 当前设备横向独立像素值 *100) / 设计稿宽度**</span>
3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / 100** </span>
4. 增加 JS 代码进行实时适配

优势：编写样式时直接挪动小数点即可。

```JS
<script>

    //总结: 
    // 1. 动态蛇者根字体的大小
    // 2. 写样式的时候,写rem单位. 值是由设计稿的值/100

    function adapter (){
        // 1. 动态的设置根字体的大小
        //根字体 = ( 设备横向独立像素值 * 100 )  / 设计稿宽度
        const rootFontSize = document.documentElement.clientWidth * 100 / 375
        document.documentElement.style.fontSize = rootFontSize + 'px'
    }
    adapter()
    window.onresize = adapter
</script>
```

##### 方法二：

搜狐、唯品会的移动端页面用的此方案

1. 设置完美视口
2. <span style="color:#ee0b41">通过js设置根字体大小  = **当前设备横向独立像素值 / 10** </span>
3. <span style="color:#ee0b41">编写样式时，直接以rem为单位，值为：**设计值 / (设计稿宽度 / 10)**</span>
4. 增加 JS 代码进行实时适配

```JS
 <script>

    // 总结: 
    // 1. 设备根字体大小 设备独立像素宽度 / 10 
    // 2. 写样式的时候,用设计高稿的值/根字体大小 单位是rem
     function adapter (){
        //根字体: 当前设备独立像素宽度 / 10
        const rootFontSize = document.documentElement.clientWidth / 10
        document.documentElement.style.fontSize = rootFontSize + 'px'
    }
    adapter()
    window.onresize = adapter
</script>
```



### 3.vw适配

vw和vh是两个相对单位（100vw=屏幕宽度）

- 1vw = 等于布局视口宽度的1%
- 1vh = 等于布局视口高度的1%



不过vw和vh有一定的兼容性问题：详见：[这里](https://www.caniuse.com/#search=vw)

### 4.1px物理像素边框

高清屏幕下 1px 对应更多的物理像素，所以 1 像素边框看起来比较粗，解决方法如下

#### 方法一

使用媒查询：

```css
@media screen and (-webkit-min-device-pixel-ratio:2){
    #demo{
        border: 0.5px solid black;
    }
}
```

#### 方法二

​	根据dpr扩大布局视口，例如dpr为n则布局视口改为原来的n倍，则元素尺寸均变为原来的n分之一，为了保证元素尺寸比例不变，扩大根字体为原来的n倍，但整个过程中边框一直用px作为单位，不用rem。

1. rem 页面布局

```js
function mobile (){
   document.documentElement.style.fontSize = (document.documentElement.clientWidth * 100)/375 + 'px'
}
mobile()
window.onresize = mobile
```

2. 元素的边框设置为 1px

3. 通过 viewport 中的 initial-scale 将布局视口扩大n倍，这样页面元素就比原来缩小了n倍

```js
var viewport = document.querySelector('meta[name=viewport]')
var scale = 1 / window.devicePixelRatio
viewport.setAttribute('content', 'width=device-width,initial-scale=' + scale);
```

4. 重新设置根元素字体

```js
var fontSize = parseInt(document.documentElement.style.fontSize);
document.documentElement.style.fontSize = fontSize * window.devicePixelRatio + 'px'
```

# axios

```JS
/*
  1. 为什么axios既能当做函数调用，也能当做对象使用？
    axios({}) --> instance({}) --> request({})
      因为改变了this指向，所以this指向context（就是Axios的实例对象）
    axios.get(url)
      将Axios.prototype的方法复制到instance（axios）上
      utils.extend(instance, Axios.prototype, context);
      
  2. Axios 和 axios 之间的联系
    axios是不是Axios的实例对象？不是，context才是
    但是axios有Axios上的方法（与Axios实例功能很相似，但不完全一样）

  3. axios的功能
    本身是一个request函数
    有 get、post...等方法
    有 defaults、interceptors等属性
    有 create 、all、Cancel 等方法

  4. axios和axios.create()返回的axios有什么区别？
    本身是一个request函数
    有 get、post...等方法
    有 defaults、interceptors等属性

    没有 create 、all、Cancel 等方法
*/
```



#### 使用xhr封装axios

```JS
function axios({
        method, // 请求方式
        url, // 请求地址
        data, // 请求体参数 body
        params, // querystring 查询字符串参数
      }) {
        return new Promise((resolve, reject) => {
          method = method.toUpperCase();
          // 1. 创建xhr对象
          const xhr = new XMLHttpRequest();
          // 2. 绑定onreadystatechange事件
          // 当readystate发生变化时触发的事件
          xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
              // 响应返回了（但是成功、失败不知道）
              if (xhr.status >= 200 && xhr.status < 300) {
                // 响应成功
                const response = {
                  request: xhr,
                  status: xhr.status,
                  data: JSON.parse(xhr.responseText),
                };
                resolve(response);
              } else {
                // 响应失败
                console.log("error", xhr);
                reject("error");
              }
            }
          };
          /*
            通常情况下：
              GET、DELETE请求，只会有查询字符串参数
              POST、PUT、PATCH请求，既可以有请求体参数，也可以有查询字符串参数
            params: { name: 'jack', age: 18 } 
              --> url?name=jack&age=18
          */
          let qs = "";
          if (params) {
            // 提取params中所有属性名成为一个数组
            // ['name', 'age']
            qs = Object.keys(params)
              .reduce((p, key) => {
                const value = params[key];
                return p + `${key}=${value}&`;
              }, "?")
              .slice(0, -1);
          }

          // 3. 设置请求信息（请求地址、请求方法。。。）
          xhr.open(method, url + qs);

          let body = "";
          if (
            (method === "POST" || method === "PUT" || method === "PATCH") &&
            data
          ) {
            // 设置请求头
            xhr.setRequestHeader("content-type", "application/json");
            body = JSON.stringify(data);
          }
          // 4. 发送请求
          xhr.send(body);
        });
      }
```



#### xhr.status

- 2XX: 表示成功处理请求, 如200, 201
- 3XX: 需要生定向, 浏览器直接跳转, 如302
- 4XX: 客户端请求错误, 如:  401, 404 
- 5XX: 服务器端错误, 如: 500

#### 区别ajax请求与一般HTTP请求

- ajax请求是一种特别的http请求
- 对服务器端来说, 没有任何区别, 区别在浏览器端
- 浏览器端发请求: 只有XHR或fetch发出的才是ajax请求, 其它所有的都是非ajax请求
- 浏览器端接收到响应
  - 一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面
  - ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据

#### 封装一个简易的ajax异步请求函数

```js
/* 
xhr + promise 封装一个异步ajax请求的通用函数  简洁版
*/
function ajax(url) {
  return new Promise((resolve, reject) => {
    // 创建一个XHR对象
    const xhr = new XMLHttpRequest()
    // 初始化一个异步请求(还没发请求)
    xhr.open('GET', url, true)
      
    xhr.onreadystatechange = function () { 
        /*
        ajax引擎得到响应数据后
        	将xhr的readyState属性指定为4
        	将响应数据保存在response / responseText属性上
        	调用此回调函数
        */
        
      // 如果状态值不为4, 直接结束(请求还没有结束)
      if (xhr.readyState !== 4) {
        return
      }
      // 如果响应码在200~~299之间, 说明请求都是成功的
      if (xhr.status>=200 && xhr.status<300) {
        // 指定promise成功及结果值
        resolve(JSON.parse(xhr.responseText))
      } else { // 请求失败了
        // 指定promise失败及结果值
        reject(new Error('request error staus '+ request.status))
      }
    }
    xhr.send(null)
  })
}

/* 
xhr + promise 封装一个异步ajax请求的通用函数  加强版
  返回值: promise
  参数为配置对象
    url: 请求地址
    params: 包含所有query请求参数的对象
    data: 包含所有请求体参数数据的对象
    method: 为请求方式
*/
function axios({url, params={}, data={}, method='GET'}) {
  // 返回一个promise对象
  return new Promise((resolve, reject) => {
    // 创建一个XHR对象
    const request = new XMLHttpRequest()
    
    // 根据params拼接query参数
    let queryStr = Object.keys(params).reduce((pre, key) => {
      pre += `&${key}=${params[key]}`
      return pre
    }, '')
    if (queryStr.length>0) {
      queryStr = queryStr.substring(1)
      url += '?' + queryStr
    }
    // 请求方式转换为大写
    method = method.toUpperCase()
    
    // 初始化一个异步请求(还没发请求)
    request.open(method, url, true)
    // 绑定请求状态改变的监听
    request.onreadystatechange = function () {
      // 如果状态值不为4, 直接结束(请求还没有结束)
      if (request.readyState !== 4) {
        return
      }
      // 如果响应码在200~~299之间, 说明请求都是成功的
      if (request.status>=200 && request.status<300) {
        // 准备响应数据对象
        const responseData = {
          data: JSON.parse(request.response),
          status: request.status,
          statusText: request.statusText
        }
        // 指定promise成功及结果值
        resolve(responseData)
      } else { // 请求失败了
        // 指定promise失败及结果值
        const error = new Error('request error staus '+ request.status)
        reject(error)
      }
    }

    // 如果是post/put请求
    if (method==='POST' || method==='PUT' || method==='DELETE') {
      // 设置请求头: 使请求体参数以json形式传递
      request.setRequestHeader('Content-Type', 'application/json;charset=utf-8')
      // 包含所有请求参数的对象转换为json格式
      const dataJson = JSON.stringify(data)
      // 发送请求, 指定请求体数据
      request.send(dataJson)
    } else {// GET请求
      // 发送请求
      request.send(null)
    }
  })
}
```



#### 跨域

- 什么是跨域(同源策略)
- JSONP
- CORS
- 代理服务器



#### 同源策略

- 同源: 协议, 域名, 端口, 三者都相同
- ajax请求时, 浏览器要求当前网页和Server必须同源(安全), 否则会抛出跨域的错误
- 加载image/link/script不受同源策略限制

#### JSONP原理

- 前台:

  - <script src="目标url?callback=fn" />

  - 接收响应数据的函数: function fn (data) {}

- 后台

  - 处理请求, 产生需要返回的数据data
  - 读取callback请求参数得到前台处理响应数据的函数名fn
  - 返回执行函数fn的js代码: 'fn && fn(data)'

- 不足

  - 只能处理GET请求
  - 每个请求在后台都要做处理, 麻烦

  ```js
  // 发送jsonp请求的函数
  function jsonp() {
      var script = document.createElement('script')
      script.type = 'text/javascript'
      // 传参并指定回调执行函数为backFn
      script.src = 'http://localhost:4000/getUserInfo?id=100&callback=fn'
      document.body.appendChild(script)
  }
  
  // 回调函数, 接收响应数据
  function fn(data) {
  	console.log(data)
  }
  ```

  

#### CORS原理

- 后台: 返回允许浏览器在某个域上发送跨域请求的相关响应头

```js
// 使用cors, 允许跨域, 且允许携带跨域cookie
app.use(function (req, res, next) {
  // console.log('----')
  // 允许跨域的地址
  res.header('Access-Control-Allow-Origin', 'http://localhost:5500')  // 不要是*
  // 允许携带凭证(也就是cookie)
  res.header('Access-Control-Allow-Credentials', 'true')
  // 允许跨域的请求头
  res.set("Access-Control-Allow-Headers", "Content-Type")
  // 放行
  next()
})
```

- 前台: 不需要做特别任何处理

```js
axios.defaults.withCredentials = true // 允许携带cookie
xhr.withCredentials = true
```

#### 代理服务器

- 开发环境: 利用webpack-dev-server中的http-proxy-middle  进行正向代理
  - vue脚手架项目
  - react脚手架项目
  - 自定义webpack配置
  - 直接使用http-proxy-middle配置
- 生产环境: 利用nigix  进行反向代理
- https://www.cnblogs.com/taostaryu/p/10547132.html



#### 使用axios发送ajax请求

```js
axios(url)
axios({
    method: '',
    url: '',  // 如果有params参数必须拼接在url中
    params: {}, // query参数
    data: {} // 请求体参数
})
axios.get(url, {配置})
axios.post(url, data, {配置})
axios.put(url, data, {配置})
axios.delete(url, {配置})

const service = axios.create({
    baseURL: '',
    timeout: 20000,
})

service.interceptors.request.use((config) => {
   	// 添加请求头
    config.headers['token'] = token值
    return config // 必须返回config
})

xhr.send()

service.interceptors.response.use(
    response => {
        // return response
        return response.data
    },
    error => {
        
    }
)


service({}).then(data => {
    
})


Promise.resolve(config)
    .then((config) => {  // 请求拦截器的回调
    	return config
	})  
    .then((config) => { // 用来发ajax的回调
        return new Promise((resolve, reject) => {
            // 根据config使用xhr发请求
            resolve(response)
        })
    })
	.then(   // 响应拦截器
        (response) => {
            return response.data
        }, 
        (error) => {
            
        }
	)
	.then((data) => { // 最终发具体请求的成功回调
    
	})
```

#### axios二次封装

1. 配置通用的基础路径和超时

2. 显示请求进度条
   1. 显示进度条: 请求拦截器回调
   2. 结束进度条: 响应拦截器回调

3. 成功返回的数据不再是response, 而直接是响应体数据response.data

4. 统一处理请求错误, 具体请求也可以选择处理或不处理

5. 每个请求自动携带userTempId的请求头: 在请求拦截器中实现

6. 如果当前有token, 自动携带token的请求头
7. 对token过期的错误进行处理

```js
import axios from 'axios'
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'
import store from '@/store'
import router from '@/router'

NProgress.configure({ showSpinner: false }) // 隐藏右侧的旋转进度条

// 创建instance
const instance = axios.create({
  // baseURL: 'http://182.92.128.115/api',
  baseURL: '/api',
  timeout: 20000
})

// 指定请求拦截器
instance.interceptors.request.use(config => {
  // 显示进度条: 请求拦截器回调
  NProgress.start()

  /* 每个请求自动携带userTempId的请求头: 在请求拦截器中实现 */
  const userTempId = store.state.user.userTempId
  config.headers.userTempId = userTempId
  
  /* 6. 如果当前有token, 自动携带token的请求头 */
  const token = store.state.user.token
  if (token) {
    config.headers.token = token
  }
  
  return config // 必须返回config
}) 


// 指定响应拦截器
instance.interceptors.response.use(
  response => { // 成功的回调
    // 结束进度条: 响应拦截器回调
    NProgress.done()
    // 成功返回的数据不再是response, 而直接是响应体数据response.data
    return response.data
  },

  async error => { // 失败的回调
    // 结束进度条: 响应拦截器回调
    NProgress.done()

    // 统一处理请求错误, 具体请求也可以选择处理或不处理
    // alert('请求出错: ' + error.message||'未知错误')

    // 取出响应对象
    const { response } = error
    // 如果是请求处理出错
    if (response && response.status) {
      // 401说明token非法
      if (response.status === 401) {
        // 如果当前没在登陆页
        if (router.currentRoute.path!=='/login') {
          // 分发action去清除用户token信息
          await store.dispatch('logout')
          // 跳转到登陆页面
          router.replace('/login')
          // 提示
          message.error('登陆已过期, 请重新登陆')
        }
      } else {
        message.error('请求出错: ' + error.message||'未知错误')
      }
    } else if (!response) { // 网络连接不上服务器
      message.error('您的网络发生异常，无法连接服务器')
    }

    // throw error
    return Promise.reject(error) // 将错误向下传递
  }
)

// 向外暴露instance
export default instance
```



#### Restless API 与 Restful API

- Restless API  

  - 传统的API, 把每个url当作一个功能操作      /deleteUser
  - 同一个url, 后台只进行CRUD的某一种操作
  - 请求方式不决定请求的CRUD操作
  - 一个请求路径只对应一个操作
  - 一般只有GET/POST

- Restful API 

  - 新式的API, 把每个url当作一个唯一资源   /user/2
  - 同一个url, 可以通过不同类型的请求对后台资源数据进行CRUD四种操作
  - 请求方式来决定了请求在后台进行CRUD的哪种操作
    - GET: 查询
    - POST: 添加
    - PUT: 更新
    - DELETE: 删除
  - 同一个请求路径可以进行多个操作
  - 请求方式会用到GET/POST/PUT/DELETE

- 测试: 可以使用json-server快速搭建模拟的rest api 接口