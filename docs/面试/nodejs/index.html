<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">nodeJS | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://Minyym.github.io/my-website/docs/面试/nodejs"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="nodeJS | My Site"><meta data-react-helmet="true" name="description" content="分析node的外层函数"><meta data-react-helmet="true" property="og:description" content="分析node的外层函数"><link data-react-helmet="true" rel="shortcut icon" href="/my-website/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Minyym.github.io/my-website/docs/面试/nodejs"><link data-react-helmet="true" rel="alternate" href="https://Minyym.github.io/my-website/docs/面试/nodejs" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Minyym.github.io/my-website/docs/面试/nodejs" hreflang="x-default"><link rel="stylesheet" href="/my-website/assets/css/styles.cf43b5b1.css">
<link rel="preload" href="/my-website/assets/js/runtime~main.f18ee25f.js" as="script">
<link rel="preload" href="/my-website/assets/js/main.d956687a.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/my-website/"><b class="navbar__title">Yym</b></a><a class="navbar__item navbar__link navbar__link--active" href="/my-website/docs/JS基础/new">JS</a><a class="navbar__item navbar__link navbar__link--active" href="/my-website/docs/TS/ts基础">TS</a><a class="navbar__item navbar__link navbar__link--active" href="/my-website/docs/ES/函数的扩展">ES</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/Minyym/my-website" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Big</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">CSS</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">ES</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">GIT</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">JS基础</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Personal-skills</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">TS</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Taro</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">babel</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/my-website/docs/stockin_stock_sku  进销存 库存账单 入库明细stockout_stock_sku 进销存 库存账表 出库明细stockout_stock_summary_by_spulist  出入库汇总 - 销售出库汇总">stockin_stock_sku  进销存 库存账单 入库明细stockout_stock_sku 进销存 库存账表 出库明细stockout_stock_summary_by_spulist  出入库汇总 - 销售出库汇总</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">webpack</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">业务</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">未分类</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">浏览器</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">算法</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">计算机组成原理</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">设计模式</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">面试</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/css html">HTML，CSS</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/dom  bom">DOMBOM</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/js">js</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/es">ES5+</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/my-website/docs/面试/nodejs">nodeJS</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/手写代码">手写XXX</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/代码操作">代码操作</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/webpack">webpack</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/移动端">移动端</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/axios">axios</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/react">react</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/浏览器">浏览器</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/1">1</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>nodeJS</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="分析node的外层函数"></a>分析node的外层函数<a class="hash-link" href="#分析node的外层函数" title="Direct link to heading">#</a></h2><ol><li>在nodeJS中，每一个JS模块都包裹了一层函数。</li><li>在JS中，通过<code>arguments.callee.toString()</code>可以看到一个函数：</li><li><code>function (exports, require, module, __filename, __dirname) {}</code></li><li>这个函数是所有模块都有的，node编译时往其中注入5个参数：<ul><li>exports 暴露模块</li><li>require 引入模块</li><li>module exports属性暴露模块</li><li>__filename 文件的绝对路径</li><li>__dirname 文件夹的绝对路径</li></ul></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈buffer"></a>谈一谈Buffer<a class="hash-link" href="#谈一谈buffer" title="Direct link to heading">#</a></h2><ol><li>Buffer是一个和数组类似的对象，不同是Buffer是专门用来保存二进制数据的(数据储存为二进制数据，性能是最好的)。</li><li>Buffer 类在全局作用域中，在Global上，可以直接使用，因此无需使用 require(&#x27;buffer&#x27;).Buffer</li></ol><p>特点</p><ol><li>大小固定：在创建时就确定了，且无法调整</li><li>性能较好：直接对计算机的内存进行操作</li><li>每个元素大小为1字节</li></ol><p>方法</p><ol><li><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0（打印出来的是十六进制），如果设置了，长度不够就自动的重复进行补全。</li><li><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</li><li><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例，打印出来的是十六进制的数字，额有使用forEash遍历，遍历出来的是十进制。可以使用toString()方法进行转换话汉字。</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈谈process"></a>谈谈process<a class="hash-link" href="#谈谈process" title="Direct link to heading">#</a></h2><ol><li><code>process</code> 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 <code>require()</code>。 它也可以使用 <code>require()</code> 显式地访问：</li></ol><p>方法和属性</p><ol><li>argv 属性返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数</li><li>argv0 属性保存当 Node.js 启动时传入的 <code>argv[0]</code> 的原始值的只读副本,也就是获取nodejs程序目录</li><li>cwd() 方法返回 Node.js 进程的当前工作目录。绝对路径</li><li>exit([code]) 退出进程</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈谈pathresolve方法"></a>谈谈path.resolve方法<a class="hash-link" href="#谈谈pathresolve方法" title="Direct link to heading">#</a></h2><p>path.resolve([...paths]) 方法将路径或路径片段的序列解析为绝对路径</p><p>建议参数加上<code>__dirname</code>。即<code>path.resolve(__dirname,&quot;路径&quot;)</code>。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈fs文件系统"></a>谈一谈fs文件系统<a class="hash-link" href="#谈一谈fs文件系统" title="Direct link to heading">#</a></h2><ol><li><p>全称为file system，所谓的文件系统，就是对计算机中的文件进行增删改查等操作。它是一个服务器的基础，在Node中通过fs模块来操作文件系统。</p></li><li><p><strong>const</strong> <strong>fs</strong> <strong>=</strong> require(&#x27;fs&#x27;);引入使用</p></li><li><p>fs中的大部分方法都为我们提供了两个版本：</p><ul><li>同步方法：带sync的方法<ul><li>同步方法会阻塞程序的执行</li><li>同步方法通过返回值返回结果</li></ul></li><li>异步方法：不带sync的方法<ul><li>异步方法不会阻塞程序的执行</li><li>异步方法都是通过回调函数来返回结果的</li></ul></li></ul></li><li><p>文件的同步写入</p><ul><li>打开文件：<code>fs.openSync(filePath[,flags,mode])</code><ul><li>filePath：当前的文件路径</li><li>flags：文件系统标志 <code>&quot;a&quot;/&quot;w&quot;/&quot;r&quot;</code></li><li>mode：默认值是0o666（文件可读可写）、0o111（文件可执行）、0o222（文件可写入）、0o333（文件读取） 一般不设置，mode 就使用其默认值</li><li>返回的是文件描述符的整数</li></ul></li><li>写入内容：<code>fs.writeSync(fd,string[,position[,encoding]])</code><ul><li>fd：要写入的文件的描述符</li><li>string：要写入的内容</li><li>position：写入的起始位置</li><li>encoding：写入文件的编码，默认utf-8</li></ul></li><li>关闭文件：<code>fs.closeSync(fd)</code><ul><li>fd：文件描述符，通过fd来对文件进行操作</li></ul></li></ul></li><li><p>文件的异步写入</p><p>异步写入一般都有回调函数</p><ul><li><p>打开文件：<code>fs.open(filePath,flags[,mode],callback)</code></p><ul><li><p>callback：回调函数，异步方法通过回调函数返回文件的描述符（fd），同步代码是通过返回值返回。</p></li><li><p>回调函数的参数：(err,fd)</p><p>err：错误对象。错误优先机制</p></li><li><p>返回值：文件描述符</p></li></ul></li><li><p>写入内容：<code>fs.write(fd,string[,position,[encoding]],callback)</code></p></li><li><p>关闭文件：<code>fs.close(fd,callback)</code></p></li></ul></li><li><p>文件的简单写入</p><ul><li>同步方法：<code>fs.writeFileSync(filePath,data[,options])</code></li><li>异步方法：<code>fs.writeFile(filePath,data[,opations],callback)</code></li></ul></li><li><p>文件的简单读取</p><ul><li>同步方法：<code>fs.readFileSync(filePath[,opations])</code></li><li>异步方法：<code>fs.readFile(filePath[,opations],callback)</code></li></ul></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="书写一个快速读写文件"></a>书写一个快速读写文件<a class="hash-link" href="#书写一个快速读写文件" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const fs = require(&quot;fs&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const path = require(&quot;path&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//拼接路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const readFilePath = path.resolve(__dirname, &quot;./a.mp4&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const writeFilePath = path.resolve(__dirname, &quot;./b.mp4&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建一个可读流</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const rs = fs.createReadStream(readFilePath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建一个可写流</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const ws = fs.createWriteStream(writeFilePath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//快速读写</span></span><span class="token-line" style="color:#393A34"><span class="token plain">rs.pipe(ws);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈加密"></a>谈一谈加密<a class="hash-link" href="#谈一谈加密" title="Direct link to heading">#</a></h2><ul><li><p><code>crypto</code> 模块提供了加密功能，共有四种消息加密算法（md5、sha1、sha256、sha512）</p></li><li><p>特点</p><ul><li>生成的密文长度固定</li><li>同样的明文加密后一定得到同样的密文</li><li>不可逆</li></ul></li><li><p>使用方法</p><ul><li>使用<code>createHmac()</code>方法可以生成一个HMAC对象，参数是加密方式和明文</li><li>通过<code>digest()</code>方法可以把HMAC对象转换成16进制，参数是<code>&#x27;hex&#x27;</code></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">//引入加密模块</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const crypto = require(&quot;crypto&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//假设拿到了需要加密的信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">let secret = &#x27;lph15701665563&#x27;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//可以给明文加点料</span></span><span class="token-line" style="color:#393A34"><span class="token plain">secret += &#x27;nice1&#x27;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//使用createHmac方法可以生成一个HMAC对象 参数是加密方式 和 明文</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const hash = crypto.createHmac(&#x27;MD5&#x27;, secret);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//通过digest可以把HMAC对象转换成16进制显示或保存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const mySecret = hash.digest(&quot;hex&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//可以对密文再次加密 然后再存到数据库 会更安全</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const hash2 = crypto.createHmac(&#x27;sha256&#x27;, mySecret);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const mySecret2 = hash2.digest(&quot;hex&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(mySecret2);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="nodejs搭建一个服务端并返回一个html数据"></a>nodejs搭建一个服务端，并返回一个html数据<a class="hash-link" href="#nodejs搭建一个服务端并返回一个html数据" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">const http = require(&quot;http&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建一个服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const server = http.createServer((request, response) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //设置报文头部</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=utf-8&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //响应数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    response.end(&quot;&lt;h1&gt;湖人总冠军&lt;/h1&gt;&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const host = &quot;localhost&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">const port = 3000;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//启动服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">server.listen(port, host, (err) =&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (err) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        console.log(&quot;服务器启动失败：&quot; + err);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(`服务器启动成功:请访问 http://${host}:${port}`)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="什么是http协议"></a>什么是http协议<a class="hash-link" href="#什么是http协议" title="Direct link to heading">#</a></h2><ol><li><p>协议就是：在网络通信中，两台计算机必须准守的规则或者规定。</p></li><li><p>http协议就是：超文本传输协议。在万维网中，服务器向浏览器传递超文本的时候准守的协议。</p></li><li><p>在客户端和服务端互传的信息称作为报文，http协议规定了报文的格式。服务端响应的报文称作为响应报文，客户端发送的报文称作为请求报文</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="请求方式及解析"></a>请求方式及解析<a class="hash-link" href="#请求方式及解析" title="Direct link to heading">#</a></h2><p>1.GET请求：（查）</p><p>​      用于请求指定的页面信息，并返回一个实体</p><p>​      数据会在url地址上边发送（查询字符串 queryString）</p><p> 2.POST(增)</p><p>​      - 向指定的资源提交数据进行处理（登录注册）</p><p>​      - 数据会在报文体中发送</p><p>  3.PUT(改)</p><p>​      - 更改服务器数据</p><p>​      - 发送文件</p><p>  4.DELETE(删)</p><p>​      - 删除指定的数据</p><p>​    5.OPTIONS（预检）</p><p>​      - 提前检查服务器支持的请求类型</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="get和post的区别"></a>GET和POST的区别<a class="hash-link" href="#get和post的区别" title="Direct link to heading">#</a></h2><ol><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li><li><a href="https://mp.weixin.qq.com/s/UK9XlxOOsSt4h6xAhcGuDQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/UK9XlxOOsSt4h6xAhcGuDQ</a></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="常见响应状态码status"></a>常见响应状态码（status）<a class="hash-link" href="#常见响应状态码status" title="Direct link to heading">#</a></h2><p>1XX: 正在响应</p><p>​      100：请求继续，请继续发送请求</p><p>​      101：协议切换中</p><p>​    2XX: 响应成功</p><p>​      200：请求成功</p><p>​      204：请求成功，但是页面不需要任何更新</p><p>​      206：范围请求，只请求的部分资源</p><p>​    3XX: 重定向</p><p>​      301：永久重定向</p><p>​      302：临时重定向</p><p>​      304：读取缓存</p><p>​    4XX: 客户端错误导致响应失败</p><p>​      400：请求报文中有语法错误</p><p>​      403: 服务器拒绝客户端访问</p><p>​      404：找不到资源</p><p>​    5XX: 服务器错误</p><p>​      500：服务器出现了问题</p><p>​      503：服务器正在忙</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="什么是tcp三次握手"></a>什么是TCP三次握手<a class="hash-link" href="#什么是tcp三次握手" title="Direct link to heading">#</a></h2><p>在发送数据之前，客户端和服务端要建立连接，所谓的建立连接其实就是双方都保存有对方的信息</p><p>​    TCP三次握手的意义在于：客户端和服务端都能知道对方的接收和发送能力正常。</p><p>​    1.客户端向服务端发送数据包，服务端收到数据包，说明客户端的发送能力正常</p><p>​    2.服务端接收到数据包之后，向客户端发送数据包，客户端接收的服务端的数据包之后，说明服务端的接受和发送能力正常</p><p>​    3.客户端继续向服务端发送数据包，服务端接受到数据包之后，说明客户端的接受能力也正常</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="什么是tcp四次挥手"></a>什么是TCP四次挥手<a class="hash-link" href="#什么是tcp四次挥手" title="Direct link to heading">#</a></h2><p>客户端和服务端总共要发送4个数据包，保证双方都知道对方的数据发送完毕</p><p>​    1.客户端发送数据包，表示请求数据发送完毕</p><p>​    2.服务端接受到客户端的释放信号，向客户端发送数据包，表示已经接收到客户端发送的释放信号</p><p>​    3.服务端的数据发送完毕后，会主动给客户端发送数据包，表示服务端的响应数据发送完毕</p><p>​    4.客户端向服务端发送数据包，表示收到，并同意断开连接</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="从输入url到解析出页面-中间经历的过程"></a>从输入url到解析出页面 中间经历的过程<a class="hash-link" href="#从输入url到解析出页面-中间经历的过程" title="Direct link to heading">#</a></h2><ol><li><p>DNS查询 / 解析</p><p>将域名地址解析成ip地址（4个缓存 1个递归查询）</p><ul><li>浏览器DNS缓存</li><li>计算机DNS缓存</li><li>路由器DNS缓存</li><li>网络运营商DNS缓存<ul><li>.com --&gt; d.com --&gt; c.d.com --&gt; b.c.d.com --&gt; a.b.c.d.com</li></ul></li></ul></li><li><p>TCP连接： TCP三次握手</p></li><li><p>发送请求：</p><ul><li><p>按照HTTP协议的规定，生成请求报文，浏览器将请求报文发送给服务器</p></li><li><p>浏览器将请求报文发送给服务器</p></li></ul></li><li><p>返回响应</p><ul><li>按照HTTP协议的规定，生成相应报文，服务器将请求报文发送给客户端</li></ul></li><li><p>渲染页面：</p><ol><li><p>解析html生成DOM树</p><ul><li>因为浏览器无法直接理解和使用 html 文件，所以需要将 html 文件转为浏览器能够理解的结构 DOM 树</li><li>输入：html 文件</li><li>输出：DOM 树</li><li>操作过程：解析 html 结构为浏览器可以理解的 DOM 树结构，期间会去下载次级资源以及执行 js 代码。</li></ul></li><li><p>.解析css生产CSSOM树</p><p>样式计算是为了获取每个节点的样式，其主要分为三步来完成。</p><ul><li><p>转成浏览器可以理解的数据结构styleSheets，可以在开发者工具上通过 document.styleSheets 打印出来。只需要了解到主进程会将 css 代码转成浏览器可以理解的结构，这个结构支持查询和修改。可以在开发者工具上通过 document.styleSheets 打印出来。</p></li><li><p>将 css 转成标准化的样式</p><p>比如 rem 转成 px、bule 转成 rgba 等。</p></li><li><p>最后是计算每个节点的样式。</p><p>这一步骤涉及到 css 的继承规则和层叠规则。有些属性是可以被子元素继承的，有些属性是会覆盖前面的样式</p></li></ul></li><li><p>.解析js，可能会对DOM和样式修改</p></li><li><p>根据DOM树和CSSOM树，生成渲染树（render Tree）</p><p>想要渲染一个完整的页面，仅知道 DOM 树和 DOM 树元素的样式还是不够的，我们还需要知道 DOM 树中元素的位置。同样的布局这个子阶段也分为两个过程操作，分别是合成布局树和计算节点位置。</p><ul><li><p>合成布局树</p><p>布局树和 DOM 树类似，不过布局树上只包含会显示的节点内容，不包含 display: none 样式的元素。只包含可见节点</p></li><li><p>计算节点位置</p><p>有了一颗完成的布局树，主线程会计算出每个元素的位置信息以及盒子大小</p></li></ul></li><li><p>分层：根据层叠上下文属性，将渲染树的节点进行分层</p><p>因为页面有很多复杂的效果，比如滑动、z-idnex 等。为了更好的实现这些效果，渲染引擎<strong>主线程</strong>还需要为特定的阶段生成专用的图层，并生成一颗对应的<strong>图层树</strong>。</p><ul><li><p>拥有层叠上下文属性的元素会单独生成一个图层。</p><ul><li>3D 或透视变换的 css 属性</li><li>使用加速视频解码的 video 元素</li><li>canvas 元素</li><li>opacity 属性</li></ul></li><li><p>需要裁剪的地方也会单独生成一个图层</p><p>裁剪就是需要滚动的地方，里面内容会单独生成一个图层。如果有滚动条，滚动条也会单独生成一个图层</p></li></ul></li><li><p>生成图层绘制指令</p><p>在完成图层树的构建之后，渲染引擎<strong>主线程</strong>会对每个图层进行绘制。这里说的绘制不是真正的绘制画面，而是生成一个绘制指令列表。</p><p>将每个图层的绘制拆分成多个绘制指令，传给<strong>合成线程</strong>。</p></li><li><p>栅格化：将图层划分为图块</p><p>绘制指令生成之后，渲染进程<strong>主线程</strong>会将绘制指令发送给<strong>合成线程</strong>，由合成线程来完成最后的绘制工作。合成线程会将图层划分为<strong>图块</strong>。</p></li><li><p>合成和显示</p><p>等所有图块都被栅格化，<strong>合成线程</strong>会收集位图信息来创建<strong>合成帧</strong>。合成帧随后会通过 IPC 协议将消息传给<strong>浏览器主进程</strong>。浏览器主进程收到消息后，会将页面内容绘制到内存中，最后再将内存显示在屏幕上。</p></li></ol></li><li><p>断开连接：TCP四次挥手</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="mime类型"></a>MIME类型<a class="hash-link" href="#mime类型" title="Direct link to heading">#</a></h2><table><thead><tr><th><strong>application/octet-stream</strong></th><th><strong>应用程序文件</strong></th></tr></thead><tbody><tr><td><strong>text/plain</strong></td><td><strong>文本文件</strong></td></tr><tr><td><strong>text/css</strong></td><td><strong>css**</strong>文件**</td></tr><tr><td><strong>text/html</strong></td><td><strong>html**</strong>文件**</td></tr><tr><td><strong>application/javascript</strong></td><td><strong>js**</strong>文件**</td></tr><tr><td><strong>image/gif</strong></td><td><strong>GIF</strong> <strong>图片</strong></td></tr><tr><td><strong>image/jpeg</strong></td><td><strong>JPEG/JPG</strong> <strong>图片</strong></td></tr><tr><td><strong>image/png</strong></td><td><strong>PNG</strong> <strong>图片</strong></td></tr><tr><td><strong>image/svg+xml</strong></td><td><strong>SVG**</strong>图片 (矢量图)**</td></tr><tr><td><strong>image/x-icon</strong></td><td><strong>icon**</strong>图片**</td></tr><tr><td><strong>application/json</strong></td><td><strong>json**</strong>文件**</td></tr><tr><td><strong>multipart/form-data</strong></td><td>上传文件</td></tr><tr><td><strong>application/x-www-form-urlencoded</strong></td><td>Form表单格式</td></tr><tr><td><strong>audio/webm</strong></td><td><strong>WebM</strong> <strong>音频文件格式</strong></td></tr><tr><td><strong>video/webm</strong></td><td><strong>WebM**</strong>视频文件格式的音视频文件**</td></tr></tbody></table><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈cookie"></a>谈一谈cookie<a class="hash-link" href="#谈一谈cookie" title="Direct link to heading">#</a></h2><p>1.“HTTP 是一个无状态的协议”:即使同一个客户端连续两次发送请求给服务器，服务器也识别不出这是同一个客户端发送的请求。为了解决 HTTP 无状态导致的问题，后来出现了 Cookie
2.Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据
3.Cookie作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成
4.Cookie的设置</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">- 客户端发送 HTTP 请求到服务器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">- 当服务器收到 HTTP 请求时，在响应头里面添加一个 Set-Cookie 字段</span></span><span class="token-line" style="color:#393A34"><span class="token plain">- 浏览器收到响应后保存下 Cookie</span></span><span class="token-line" style="color:#393A34"><span class="token plain">- 之后对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>5.一些设置：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">- Expires 用于设置 Cookie 的过期时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">- Max-Age 用于设置在 Cookie 失效之前需要经过的秒数</span></span><span class="token-line" style="color:#393A34"><span class="token plain">- HTTPOnly：设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈缓存"></a>谈一谈缓存<a class="hash-link" href="#谈一谈缓存" title="Direct link to heading">#</a></h2><p>1.缓存是性能优化中简单高效的一种优化方式。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷
2.缓存分为强缓存和协商缓存 </p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">- 强缓存：不会向服务器发送请求，直接从缓存中读取资源，并且显示from disk cache或from memory cache字样，强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    - 协商缓存：协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</span></span><span class="token-line" style="color:#393A34"><span class="token plain">- 描述协商缓存过程</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      1. 客户端向服务端发送一个请求,请求相应的资源</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      2. 服务端向客户端发送响应,在响应头中携带两个关于缓存的内容</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         分别是式文件的唯一标识(eTag&#x27;),文件最后一次的修改时间(last-modified)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      3. 客户端接收到响应的eTag和last-modified,并且保存在客户端,但是改名了把eTag改名位if-none-match把last-modified改名为if-modified-since</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      4. 客户端第二次请求服务端,请求指定的资源,在请求头上会携带两个字段分别是if-none-match 和 if-modified-since</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      5. 服务端接受到客户端的发送的if-none-match和 if-modified-since,和自己的重新获当前文件的eTag和last-modifined进行比较如果两个都相同,则读取缓存如果有一个不同,则返回新的响应</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      6. 如果走缓存,则服务端的响应状态码应该是304,并且不需要设置响应内容</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      7. 如果走缓存,则接收到的状态码是304,则直接读取缓存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      8. 如果不走缓存,则响应状态码是200,并且返回新的资源,还要再返回最新的eTag和last-modified</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈session"></a>谈一谈session<a class="hash-link" href="#谈一谈session" title="Direct link to heading">#</a></h2><p>1.因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态
2 Session 是基于Cookie 实现的另一种记录服务端和客户端会话状态的机制
3 Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中
4 描述Session的过程</p><ol><li>1.发送请求,请求登录,可能在报文体或者url中携带登录信息</li><li>2.服务端接收响应,创建一个session对象
然后创建一个当前用户信息的永远不重复sessionID,
把当前用户的信息和sessionID组成一个
key-value值,保存在session对象中</li><li>3.返回响应,cookie中携带了 sessionId</li><li>4.接受到sessionId,并保存在cookie中</li><li>5.第二次发送请求,会自动携带sessionId,因为在cookie中保存</li><li>6.服务端通过解析,获取到cookie中的
sessionId,去session对象中判断当前
sessionId是否存在</li><li>7.如果服务端验证成功,会直接响应相应的请求,否则需要再次登录</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="cookiesessionstoragelocalstorage的区别"></a>cookie,sessionStorage,localStorage的区别<a class="hash-link" href="#cookiesessionstoragelocalstorage的区别" title="Direct link to heading">#</a></h2><ol><li><p>生命周期:
cookie(max-age超时时间)	没有设置超时时间,浏览器关闭失效
设置超时时间,超过设置时间就作废
sessionStorage		浏览器关闭失效
localStorage		用户不主动删除或者使用API删除,永久存在</p></li><li><p>存储位置
cookie(max-age超时时间)	没有设置超时时间,存储于内存中
设置超时时间,存储于硬盘中
sessionStorage		存储于内存中
localStorage		存储于硬盘中</p></li><li><p>存储大小
cookie		4KB
sessionStorage	5MB
localStorage	20MB</p></li><li><p>与服务器之间的关系
cookie		服务器创建,浏览器存储,发送请求自动携带上
sessionStorage	跟服务器没啥关系,不熟
localStorage	跟服务器没啥关系,不熟</p></li></ol><p>token与上述的区别
token数据类型:字符串
内容:用户唯一标识-&gt;md5(盐salt)-&gt;得到base64字符串
公司中:token每15分钟左右更换一个,过期时间一般7天或者15天</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈跨域"></a>谈一谈跨域<a class="hash-link" href="#谈一谈跨域" title="Direct link to heading">#</a></h2><ol><li><p>效果:在浏览器端会出现跨域问题,小程序端没出现</p></li><li><p>什么是跨域（也就是什么是同源策略）</p><ol><li>同源:获取数据的地址必须跟url中的域名相同</li><li>跨域就是违反同源策略</li></ol></li><li><p>跨域一定会出现问题吗</p><ol><li><p>获取别人服务器上的css和js等文件时,都没有报跨域问题</p><p>只有在发送ajax请求的时候才会出现跨域问题</p></li><li><p>在小程序中发送ajax请求没报错,在浏览器端发送才报错</p><p>只有在浏览器端才会出现跨域问题</p></li><li><p>跨域的ajax请求是什么时候才会提示失败</p><p>请求报错是在响应阶段才出现的
浏览器会检测被请求的服务器是否允许别人请求,如果没有声明允许被跨域请求,就报错
结果:服务器只要允许被别人跨域请求,浏览器就不会报错</p></li></ol></li><li><p>如何解决跨域问题</p><p>1.jsonp(jq至今活着的原因)
实现原理:使用了问题二中的第一个现象
2.cors
实现原理:问题三的结果
3.proxy
问题:有没有违反同源策略
并没有违反同源策略
实现原理:当前页面都是找devServer请求数据,devServer帮你去请求其他的服务器,将返回的数据再返回给你</p></li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/Minyym/my-website/edit/master/docs/面试/5.nodejs.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/my-website/docs/面试/es"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« ES5+</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/my-website/docs/面试/手写代码"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">手写XXX »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#分析node的外层函数" class="table-of-contents__link">分析node的外层函数</a></li><li><a href="#谈一谈buffer" class="table-of-contents__link">谈一谈Buffer</a></li><li><a href="#谈谈process" class="table-of-contents__link">谈谈process</a></li><li><a href="#谈谈pathresolve方法" class="table-of-contents__link">谈谈path.resolve方法</a></li><li><a href="#谈一谈fs文件系统" class="table-of-contents__link">谈一谈fs文件系统</a></li><li><a href="#书写一个快速读写文件" class="table-of-contents__link">书写一个快速读写文件</a></li><li><a href="#谈一谈加密" class="table-of-contents__link">谈一谈加密</a></li><li><a href="#nodejs搭建一个服务端并返回一个html数据" class="table-of-contents__link">nodejs搭建一个服务端，并返回一个html数据</a></li><li><a href="#什么是http协议" class="table-of-contents__link">什么是http协议</a></li><li><a href="#请求方式及解析" class="table-of-contents__link">请求方式及解析</a></li><li><a href="#get和post的区别" class="table-of-contents__link">GET和POST的区别</a></li><li><a href="#常见响应状态码status" class="table-of-contents__link">常见响应状态码（status）</a></li><li><a href="#什么是tcp三次握手" class="table-of-contents__link">什么是TCP三次握手</a></li><li><a href="#什么是tcp四次挥手" class="table-of-contents__link">什么是TCP四次挥手</a></li><li><a href="#从输入url到解析出页面-中间经历的过程" class="table-of-contents__link">从输入url到解析出页面 中间经历的过程</a></li><li><a href="#mime类型" class="table-of-contents__link">MIME类型</a></li><li><a href="#谈一谈cookie" class="table-of-contents__link">谈一谈cookie</a></li><li><a href="#谈一谈缓存" class="table-of-contents__link">谈一谈缓存</a></li><li><a href="#谈一谈session" class="table-of-contents__link">谈一谈session</a></li><li><a href="#cookiesessionstoragelocalstorage的区别" class="table-of-contents__link">cookie,sessionStorage,localStorage的区别</a></li><li><a href="#谈一谈跨域" class="table-of-contents__link">谈一谈跨域</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/my-website/assets/js/runtime~main.f18ee25f.js"></script>
<script src="/my-website/assets/js/main.d956687a.js"></script>
</body>
</html>