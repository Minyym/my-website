## const let var 的区别

- `var`声明的变量会挂到window上，而`let`和`const`不会
- 同一作用域下`var`可以重复声明同名变量，而`let`和`const`不能
- `let`和`const`声明形成块作用域，不能跨块访问，也不能跨函数访问
- JS 变量存在「创建create、初始化initialize 和赋值assign」，var 的「创建」和「初始化」都被提升，let 的「创建」过程被提升了，但是初始化没有提升；const 只有「创建」和「初始化」，没有「赋值」过程；function 的「创建」「concat:连接数组,不修改concat:连接数组,不修改初始化」和「赋值」都被提升
- `let` 或 `const` 声明的变量拥有暂时性死区（TDZ）：范围为从进入它的作用域，这时它不能被访问（获取或设置），直到到达声明语句。死区（dead zone）是真正短暂的（基于时间）和不受空间条件限制（基于位置）
- ![img](https://pic1.zhimg.com/v2-9c8c4a0a3ce5402b1a74f488d79c74d0.jpg)



## 执行上下文栈

https://frontend.devrank.cn/traffic-information/7081514483008604174

1. JS引擎并不是一行行的解析和执行代码，而是一段段的去分析和执行，当执行一段代码时，先开始预处理，比如声明提升和函数提升
2. 在执行某段js代码的时候，会进行一个准备工作，这个准备工作用专业的说法 叫“执行上下文”，其实执行上下文也是在内存中开辟的一个空间
3. js可执行的代码分为3种类型， 全局代码  、  函数代码   、eval代码（忽略）
4. 每执行一段代码，都会创建相对应的执行上下文，在脚本中可能存在多个执行上下文
5. 因为有太多的执行上下文， JS创建了一个执行上下文栈（stack） 用来管理执行上下文
6. 当js开始解析程序的时候，最先遇到的全局代码，此时向执行上下文栈中 压入一个全局执行上下文，全局的一定是在整体运行结束以后才被清空
7. 当执行一个函数的时候  会创建一个函数的执行上下文，并压入到执行上下文栈中，只要函数执行完成，会将函数从栈里弹出
8. 每个执行上下文 都有三个重要属性：1.变量对象（VO） 2.作用域链  3.this

### 变量对象

- 变量对象是 ECMAScript规范术语。在一个执行上下文中,变量对象才被激活,只有激活的变量对象,其各种属性才能被访问

- 变量对象是与执行上下文相关的数据作用域，储存了在上下文中定义的变量和函数声明

####  全局上下文的变量对象

- `window`是预定义对象，作为JS全局函数和全局属性的占位符（全局的变量和函数就是window对象属性和方法）
- 全局执行上下文的变量对象其实就是全局对象window，node里是global

#### 函数上下文的变量对象

- 进入执行上下文  不会立马执行代码，只进行分析。此时首先第一步，变量对象包括了函数所有的形参和实参
- 检查所有声明的函数，由名称和对应值 组成一个变量对象的属性 被创建。如果变量对象已经有相同名字的属性，则完全替换
- 检查所有的声明的变量，创建键值对儿 
- 变成变量对象的属性，如果变量名和已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性

### 作用域链

- 在函数创建的时候创建一个包含全局变量对象的作用域链( scope chain)，储存在内部[[Scope]]属性中。作用域链的用途,是保证对执行环境有权访问的所有变量和函数的有序访问。
- 当查找变量时，会从当前的变量对象进行查找，如果没有找到，就会沿着作用链一层一层的进行查找，找到变量为止，如果没有找到就会报错
- 函数执行的时候会创建一个执行环境，通过复制[[Scope]]属性中的对象，构建执行环境的作用域链，并把自己的活动对象推入该作用域链的前端以此形成完整的作用域链。
- 作用域链的前端,始终都是当前执行的代码所在环境的变量对象。
- 全局执行环境的变量对象始终都是作用域链中的最后一个对象。
- 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯,直至找到标识符为止(如果找不到标识符,通常会导致错误发生)

#### 作用域

- 理解

  - 就是一块"地盘", 一个代码段所在的区域
  - 它是静态的(相对于上下文对象), 在**编写代码时就确定**了

- 分类

  - 全局作用域
  - 函数作用域
  - 没有块作用域(ES6有了)

- 作用

  - 隔离变量，不同作用域下同名变量不会有冲突

- 缺点

  - 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
  - 容易造成内存泄露

- 解决

  - 能不用闭包就不用
  - 及时释放

- 应用：定义JS模块

    * 具有特定功能的js文件

    * 将所有的数据和功能都封装在一个函数内部(私有的)

    * 只向外暴露一个包含n个方法的对象或函数

    * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能

      ```js
      /**
       * 自定义模块1
       */
      function coolModule() {
        //私有的数据
        var msg = 'atguigu'
        var names = ['I', 'Love', 'you']
      
        //私有的操作数据的函数
        function doSomething() {
          console.log(msg.toUpperCase())
        }
        function doOtherthing() {
          console.log(names.join(' '))
        }
      
        //向外暴露包含多个方法的对象
        return {
          doSomething: doSomething,
          doOtherthing: doOtherthing
        }
      }
      
      /**
       * 自定义模块2
       */
      (function (window) {
        //私有的数据
        var msg = 'atguigu'
        var names = ['I', 'Love', 'you']
        //操作数据的函数
        function a() {
          console.log(msg.toUpperCase())
        }
        function b() {
          console.log(names.join(' '))
        }
      
        window.coolModule2 =  {
          doSomething: a,
          doOtherthing: b
        }
      })(window)
      ```

### this指向

- 谁调用指向谁，只有函数再**调用时**才能确定 this 指向
- 总结 this 指向：
  - 普通函数
    - 直接调用 指向 window
      - 再 ES5 严格模式下，指向 undefined
    - 隐式调用（对象调用方法） 指向调用函数的对象
    - 显示调用（call/apply） 指向传入第一个参数
    - new 调用 指向生成实例对象
  - 回调函数
    - 定时器回调函数 window
    - DOM 事件回调函数 绑定事件的 DOM 元素
      - React
      - 普通事件回调函数 undefined
      - 箭头函数 组件实例对象
      - Vue
      - 普通事件回调函数 组件实例对象
    - 生命周期函数 组件实例对象
  - 箭头函数
    - 他没有自己的 this
    - 它外层全局/函数作用域指向的 this（离他最近包裹它的函数的 this 一致）

### this的5种绑定方式

- 默认绑定(非严格模式下this指向全局对象, 严格模式下`this`会绑定到`undefined`)
- 隐式绑定(当函数引用有**上下文对象**时, 如 `obj.foo()`的调用方式, `foo`内的`this`指向`obj`)
- 显示绑定(通过`call()`或者`apply()`方法直接指定`this`的绑定对象, 如`foo.call(obj)`)
- new绑定
- 箭头函数绑定(`this`的指向由外层作用域决定的)

## 事件循环模型（事件轮询机制）

- js代码所在运行环境（浏览器、nodejs）编译器的一种解析执行规则，js代码可以理解为是一个人在公司中具体做的事情， 而 事件循环 相当于是公司的一种规章制度。

1. 浏览器事件轮询机制
   1. JS执行代码的顺序
   2. 现在执行同步代码，在去执异步代码
   3. 流程：
      1. JS引擎会从上到下执行代码，同步代码依次执行，把响应的回调函数放到对应的事件管理模块（DOM 事件放在DOM 事件管理模块，定时器放在定时器管理模块）
      2. 事件发生或计时器到期时，管理模块会将回调函数及其数据添加到回调列队中
      3. 等初始化代码执行完毕，js引擎就会循环的检查回调队列中的回调函数，并执行
2. nodejs轮训机制（说微任务优先是没有算上script标签是宏任务，初始化的时候从前面开始轮回，再次更新的时候的，是从poll开始，最终停在了poll队列，之所以停在poll阶段，是因为要I/O任务，读文件，停在这里，有了就先处理它）
   1. .nodeJS使用了第三方库libuv，nodeJS会把一些异步操作（I/O、文件的读写）交给libuv处理。nodejs的主线程没有必要等待，可以继续处理其他事情。
   2. libuv会开启多个线程去执行这些异步操作，当异步代码操作完毕以后，会把回调函数放到回调队列中，主线程在适当的时候回去轮询回调队列。
   3. nodejs把所有的异步操作代码分为了微任务代码和宏任务代码
   4. nodejs会优先执行微任务代码，然后才执行宏任务代码
   5. 微任务：process.nextTick，Promise的then\catch\finally、queueMicrotask
   6. process.nextTick一定是最先执行，其他微任务根据书写代码依次执行
   7. 在宏任务每次执行下一个阶段之前，都会去检查微任务队列中是否有微任务需要执行，然后才会执行下一个阶段
   8. 宏任务的轮询顺序
      1. timers阶段：处理setTimeout和setInterval的回调函数
      2. pedding阶段：处理系统级别操作的回调函数
      3. idle阶段：处理nodejs内部的回调函数
      4. poll阶段：处理I/O或者网络请求等异步操作的回调函数
         1. 当poll阶段不为空的时候，那么执行完回调函数，就继续执行下个阶段check了
         2. 当poll阶段为空，会一直等待poll中有其他的回调函数
         3. 当时当 timer阶段的计时器到期了，或者check阶段有setImmediate等待执行的时候，会直接进入check阶段
      5. check阶段：setImmediate的回调函数
      6. close阶段：执行一些关闭的函数
3. H5新的MutationObserver也基于event loop   ==> 微任务
4. Promise的.then不是webAPI，没有时间管理模块
5. webApi是DOM和BOM(W3C)