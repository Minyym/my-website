<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<title data-react-helmet="true">js | My Site</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://Minyym.github.io/my-website/docs/面试/js"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="js | My Site"><meta data-react-helmet="true" name="description" content="JavaScript 是一种弱类型的、动态的语言。"><meta data-react-helmet="true" property="og:description" content="JavaScript 是一种弱类型的、动态的语言。"><link data-react-helmet="true" rel="shortcut icon" href="/my-website/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Minyym.github.io/my-website/docs/面试/js"><link data-react-helmet="true" rel="alternate" href="https://Minyym.github.io/my-website/docs/面试/js" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Minyym.github.io/my-website/docs/面试/js" hreflang="x-default"><link rel="stylesheet" href="/my-website/assets/css/styles.cf43b5b1.css">
<link rel="preload" href="/my-website/assets/js/runtime~main.c0f3f700.js" as="script">
<link rel="preload" href="/my-website/assets/js/main.116eb900.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/my-website/"><b class="navbar__title">xiaojingyu</b></a><a class="navbar__item navbar__link navbar__link--active" href="/my-website/docs/JS基础/new">JS</a><a class="navbar__item navbar__link navbar__link--active" href="/my-website/docs/TS/ts基础">TS</a><a class="navbar__item navbar__link navbar__link--active" href="/my-website/docs/ES/函数的扩展">ES</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/Minyym/my-website" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">CSS&amp;HTML</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">ES</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">GIT</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">JS基础</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">TS</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">babel</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">npm&amp;node</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">react</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">skills</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">webpack</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">前端基建</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">小程序</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">浏览器</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">算法</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">计算机组成原理</a></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">设计模式</a></li><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">面试</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/css html">HTML，CSS</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/dom  bom">DOMBOM</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/my-website/docs/面试/js">js</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/es">ES5+</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/nodejs">nodeJS</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/手写代码">手写XXX</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/代码操作">代码操作</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/webpack">webpack</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/移动端">移动端</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/axios">axios</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/react">react</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/浏览器">浏览器</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/my-website/docs/面试/1">1</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>js</h1></header><p>JavaScript 是一种弱类型的、动态的语言。</p><ul><li>弱类型，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li><li>动态，意味着你可以使用同一个变量保存不同类型的数据。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="const-let-var-的区别"></a>const let var 的区别<a class="hash-link" href="#const-let-var-的区别" title="Direct link to heading">#</a></h2><ul><li><code>var</code>声明的变量会挂到window上，而<code>let</code>和<code>const</code>不会</li><li>同一作用域下<code>var</code>可以重复声明同名变量，而<code>let</code>和<code>const</code>不能</li><li><code>let</code>和<code>const</code>声明形成块作用域，不能跨块访问，也不能跨函数访问</li><li>JS 变量存在「创建create、初始化initialize 和赋值assign」，var 的「创建」和「初始化」都被提升，let 的「创建」过程被提升了，但是初始化没有提升；const 只有「创建」和「初始化」，没有「赋值」过程；function 的「创建」「concat:连接数组,不修改concat:连接数组,不修改初始化」和「赋值」都被提升</li><li><code>let</code> 或 <code>const</code> 声明的变量拥有暂时性死区（TDZ）：范围为从进入它的作用域，这时它不能被访问（获取或设置），直到到达声明语句。死区（dead zone）是真正短暂的（基于时间）和不受空间条件限制（基于位置）</li><li><img src="https://pic1.zhimg.com/v2-9c8c4a0a3ce5402b1a74f488d79c74d0.jpg" alt="img"></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="执行上下文栈"></a>执行上下文栈<a class="hash-link" href="#执行上下文栈" title="Direct link to heading">#</a></h2><p><a href="https://frontend.devrank.cn/traffic-information/7081514483008604174" target="_blank" rel="noopener noreferrer">https://frontend.devrank.cn/traffic-information/7081514483008604174</a></p><ol><li>JS引擎并不是一行行的解析和执行代码，而是一段段的去分析和执行，当执行一段代码时，先开始预处理，比如声明提升和函数提升</li><li>在执行某段js代码的时候，会进行一个准备工作，这个准备工作用专业的说法 叫“执行上下文”，其实执行上下文也是在内存中开辟的一个空间</li><li>js可执行的代码分为3种类型， 全局代码  、  函数代码   、eval代码（忽略）</li><li>每执行一段代码，都会创建相对应的执行上下文，在脚本中可能存在多个执行上下文</li><li>因为有太多的执行上下文， JS创建了一个执行上下文栈（stack） 用来管理执行上下文</li><li>当js开始解析程序的时候，最先遇到的全局代码，此时向执行上下文栈中 压入一个全局执行上下文，全局的一定是在整体运行结束以后才被清空</li><li>当执行一个函数的时候  会创建一个函数的执行上下文，并压入到执行上下文栈中，只要函数执行完成，会将函数从栈里弹出</li><li>每个执行上下文 都有三个重要属性：1.变量对象（VO） 2.作用域链  3.this</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="变量对象"></a>变量对象<a class="hash-link" href="#变量对象" title="Direct link to heading">#</a></h3><ul><li><p>变量对象是 ECMAScript规范术语。在一个执行上下文中,变量对象才被激活,只有激活的变量对象,其各种属性才能被访问</p></li><li><p>变量对象是与执行上下文相关的数据作用域，储存了在上下文中定义的变量和函数声明</p></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="全局上下文的变量对象"></a>全局上下文的变量对象<a class="hash-link" href="#全局上下文的变量对象" title="Direct link to heading">#</a></h4><ul><li><code>window</code>是预定义对象，作为JS全局函数和全局属性的占位符（全局的变量和函数就是window对象属性和方法）</li><li>全局执行上下文的变量对象其实就是全局对象window，node里是global</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="函数上下文的变量对象"></a>函数上下文的变量对象<a class="hash-link" href="#函数上下文的变量对象" title="Direct link to heading">#</a></h4><ul><li>进入执行上下文  不会立马执行代码，只进行分析。此时首先第一步，变量对象包括了函数所有的形参和实参</li><li>检查所有声明的函数，由名称和对应值 组成一个变量对象的属性 被创建。如果变量对象已经有相同名字的属性，则完全替换</li><li>检查所有的声明的变量，创建键值对儿 </li><li>变成变量对象的属性，如果变量名和已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="作用域链"></a>作用域链<a class="hash-link" href="#作用域链" title="Direct link to heading">#</a></h3><ul><li>在函数创建的时候创建一个包含全局变量对象的作用域链( scope chain)，储存在内部[[Scope]]属性中。作用域链的用途,是保证对执行环境有权访问的所有变量和函数的有序访问。</li><li>当查找变量时，会从当前的变量对象进行查找，如果没有找到，就会沿着作用链一层一层的进行查找，找到变量为止，如果没有找到就会报错</li><li>函数执行的时候会创建一个执行环境，通过复制[[Scope]]属性中的对象，构建执行环境的作用域链，并把自己的活动对象推入该作用域链的前端以此形成完整的作用域链。</li><li>作用域链的前端,始终都是当前执行的代码所在环境的变量对象。</li><li>全局执行环境的变量对象始终都是作用域链中的最后一个对象。</li><li>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯,直至找到标识符为止(如果找不到标识符,通常会导致错误发生)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_y2LR" id="作用域"></a>作用域<a class="hash-link" href="#作用域" title="Direct link to heading">#</a></h4><ul><li><p>理解</p><ul><li>就是一块&quot;地盘&quot;, 一个代码段所在的区域</li><li>它是静态的(相对于上下文对象), 在<strong>编写代码时就确定</strong>了</li></ul></li><li><p>分类</p><ul><li>全局作用域</li><li>函数作用域</li><li>没有块作用域(ES6有了)</li></ul></li><li><p>作用</p><ul><li>隔离变量，不同作用域下同名变量不会有冲突</li></ul></li><li><p>缺点</p><ul><li>函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长</li><li>容易造成内存泄露</li></ul></li><li><p>解决</p><ul><li>能不用闭包就不用</li><li>及时释放</li></ul></li><li><p>应用：定义JS模块</p><ul><li><p>具有特定功能的js文件</p></li><li><p>将所有的数据和功能都封装在一个函数内部(私有的)</p></li><li><p>只向外暴露一个包含n个方法的对象或函数</p></li><li><p>模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI js"><pre tabindex="0" class="prism-code language-js codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">/**</span></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 自定义模块1</span></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">coolModule</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">//私有的数据</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> msg </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;atguigu&#x27;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> names </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token string" style="color:#e3116c">&#x27;I&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;Love&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;you&#x27;</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">//私有的操作数据的函数</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">doSomething</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">msg</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">toUpperCase</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">doOtherthing</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">names</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">join</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27; &#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">//向外暴露包含多个方法的对象</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">doSomething</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> doSomething</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">doOtherthing</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> doOtherthing</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">/**</span></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 自定义模块2</span></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter dom variable" style="color:#36acaa">window</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">//私有的数据</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> msg </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;atguigu&#x27;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">var</span><span class="token plain"> names </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token string" style="color:#e3116c">&#x27;I&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;Love&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;you&#x27;</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">//操作数据的函数</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">a</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">msg</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">toUpperCase</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">b</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">names</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">join</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27; &#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token dom variable" style="color:#36acaa">window</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">coolModule2</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">doSomething</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> a</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">doOtherthing</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> b</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">(</span><span class="token dom variable" style="color:#36acaa">window</span><span class="token punctuation" style="color:#393A34">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="this指向"></a>this指向<a class="hash-link" href="#this指向" title="Direct link to heading">#</a></h3><ul><li>谁调用指向谁，只有函数再<strong>调用时</strong>才能确定 this 指向</li><li>总结 this 指向：<ul><li>普通函数<ul><li>直接调用 指向 window<ul><li>再 ES5 严格模式下，指向 undefined</li></ul></li><li>隐式调用（对象调用方法） 指向调用函数的对象</li><li>显示调用（call/apply） 指向传入第一个参数</li><li>new 调用 指向生成实例对象</li></ul></li><li>回调函数<ul><li>定时器回调函数 window</li><li>DOM 事件回调函数 绑定事件的 DOM 元素<ul><li>React</li><li>普通事件回调函数 undefined</li><li>箭头函数 组件实例对象</li><li>Vue</li><li>普通事件回调函数 组件实例对象</li></ul></li><li>生命周期函数 组件实例对象</li></ul></li><li>箭头函数<ul><li>他没有自己的 this</li><li>它外层全局/函数作用域指向的 this（离他最近包裹它的函数的 this 一致）</li></ul></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="this的5种绑定方式"></a>this的5种绑定方式<a class="hash-link" href="#this的5种绑定方式" title="Direct link to heading">#</a></h3><ul><li>默认绑定(非严格模式下this指向全局对象, 严格模式下<code>this</code>会绑定到<code>undefined</code>)</li><li>隐式绑定(当函数引用有<strong>上下文对象</strong>时, 如 <code>obj.foo()</code>的调用方式, <code>foo</code>内的<code>this</code>指向<code>obj</code>)</li><li>显示绑定(通过<code>call()</code>或者<code>apply()</code>方法直接指定<code>this</code>的绑定对象, 如<code>foo.call(obj)</code>)</li><li>new绑定</li><li>箭头函数绑定(<code>this</code>的指向由外层作用域决定的)</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="事件循环模型事件轮询机制"></a>事件循环模型（事件轮询机制）<a class="hash-link" href="#事件循环模型事件轮询机制" title="Direct link to heading">#</a></h2><ul><li>js代码所在运行环境（浏览器、nodejs）编译器的一种解析执行规则，js代码可以理解为是一个人在公司中具体做的事情， 而 事件循环 相当于是公司的一种规章制度。</li></ul><ol><li>浏览器事件轮询机制<ol><li>JS执行代码的顺序</li><li>现在执行同步代码，在去执异步代码</li><li>流程：<ol><li>JS引擎会从上到下执行代码，同步代码依次执行，把响应的回调函数放到对应的事件管理模块（DOM 事件放在DOM 事件管理模块，定时器放在定时器管理模块）</li><li>事件发生或计时器到期时，管理模块会将回调函数及其数据添加到回调列队中</li><li>等初始化代码执行完毕，js引擎就会循环的检查回调队列中的回调函数，并执行</li></ol></li></ol></li><li>nodejs轮训机制（说微任务优先是没有算上script标签是宏任务，初始化的时候从前面开始轮回，再次更新的时候的，是从poll开始，最终停在了poll队列，之所以停在poll阶段，是因为要I/O任务，读文件，停在这里，有了就先处理它）<ol><li>.nodeJS使用了第三方库libuv，nodeJS会把一些异步操作（I/O、文件的读写）交给libuv处理。nodejs的主线程没有必要等待，可以继续处理其他事情。</li><li>libuv会开启多个线程去执行这些异步操作，当异步代码操作完毕以后，会把回调函数放到回调队列中，主线程在适当的时候回去轮询回调队列。</li><li>nodejs把所有的异步操作代码分为了微任务代码和宏任务代码</li><li>nodejs会优先执行微任务代码，然后才执行宏任务代码</li><li>微任务：process.nextTick，Promise的then\catch\finally、queueMicrotask</li><li>process.nextTick一定是最先执行，其他微任务根据书写代码依次执行</li><li>在宏任务每次执行下一个阶段之前，都会去检查微任务队列中是否有微任务需要执行，然后才会执行下一个阶段</li><li>宏任务的轮询顺序<ol><li>timers阶段：处理setTimeout和setInterval的回调函数</li><li>pedding阶段：处理系统级别操作的回调函数</li><li>idle阶段：处理nodejs内部的回调函数</li><li>poll阶段：处理I/O或者网络请求等异步操作的回调函数<ol><li>当poll阶段不为空的时候，那么执行完回调函数，就继续执行下个阶段check了</li><li>当poll阶段为空，会一直等待poll中有其他的回调函数</li><li>当时当 timer阶段的计时器到期了，或者check阶段有setImmediate等待执行的时候，会直接进入check阶段</li></ol></li><li>check阶段：setImmediate的回调函数</li><li>close阶段：执行一些关闭的函数</li></ol></li></ol></li><li>H5新的MutationObserver也基于event loop   ==&gt; 微任务</li><li>Promise的.then不是webAPI，没有时间管理模块</li><li>webApi是DOM和BOM(W3C)</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="继承"></a>继承<a class="hash-link" href="#继承" title="Direct link to heading">#</a></h2><ul><li><a href="https://juejin.cn/post/7166562158052900871#heading-5" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7166562158052900871#heading-5</a></li><li>原型链继承</li><li>盗用构造函数继承</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生式组合继承</li></ul><header><h1>JS基础</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="为什么javascript是单线程"></a>为什么JavaScript是单线程？<a class="hash-link" href="#为什么javascript是单线程" title="Direct link to heading">#</a></h2><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="js的数据类型和变量类型"></a>JS的数据类型，和变量类型<a class="hash-link" href="#js的数据类型和变量类型" title="Direct link to heading">#</a></h2><ol><li>数据类型<ol><li>基本数据类型：int(数值), string(字符串), boolean(布尔), null(空), undefined(未定义),Symbol，BigInt</li><li>对象数据类型： object(对象），Math，Function，Array，Date</li></ol></li><li>变量数据类型<ol><li>基本数据类型</li><li>引用数据类型</li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="分析基本数据类型和引用数据类型的区别"></a>分析基本数据类型和引用数据类型的区别<a class="hash-link" href="#分析基本数据类型和引用数据类型的区别" title="Direct link to heading">#</a></h2><ol><li><p>基本数据类型：null undefined string number boolean bigint symbol
引用数据类型：Object</p></li><li><p>基本数据类型特点：
1.我们不能给基本类型值添加属性和方法 就算添加也是获取不到的（<a href="https://blog.csdn.net/lq313131/article/details/126378369%EF%BC%89" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/lq313131/article/details/126378369）</a></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var s1 = &quot;some text&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var s2 = s1.substring(2);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//以上过程分为三步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//1.创建 String 类型的一个实例；</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//2.在实例上调用指定的方法；</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//3.销毁这个实例。</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var s1 = new String(&quot;some text&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var s2 = s1.substring(2);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">s1 = null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 为什么我们不能给基本类型扩展属性或方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var str = &quot;1234444&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">str.name = &quot;hello&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 解析如下：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var _str = new String(&quot;1234444&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">_str.name = &quot;hello&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">_str = null;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>2.基本类型的比较是值的比较
3.基本类型的变量是存放在栈区的（栈区指内存里的栈内存),栈区包括了变量的标识符和变量的值</p></li><li><p>引用类型的特点：
1.引用类型的值是可变的，我们可以为引用类型添加属性和方法
2.引用类型的值是同时保存在栈内存和堆内存中的对象
3.引用类型的比较是引用地址的比较</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="为什么一定要分堆和栈两个存储空间呢所有数据直接存放在栈中不就可以了吗"></a>为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？<a class="hash-link" href="#为什么一定要分堆和栈两个存储空间呢所有数据直接存放在栈中不就可以了吗" title="Direct link to heading">#</a></h2><ul><li>答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="eval是做什么的"></a>eval是做什么的？<a class="hash-link" href="#eval是做什么的" title="Direct link to heading">#</a></h2><ol><li><p>它的功能是把对应的字符串解析成JS代码并运行；</p></li><li><p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p></li><li><p>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#x27;(&#x27;+ str +&#x27;)&#x27;)</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="什么是window对象-什么是document对象"></a>什么是window对象? 什么是document对象?<a class="hash-link" href="#什么是window对象-什么是document对象" title="Direct link to heading">#</a></h2><ol><li>window<ol><li>BOM 的核心对象是 <code>window</code>，它表示浏览器的一个实例。是客户端浏览器对象模型的基类。</li><li>在浏览器中，<code>window</code> 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 <code>Global</code> 对象。</li><li>这意味着在网页中定义的任何一个对象、变量和函数，都以 <code>window</code> 作为其 <code>Global</code> 对象，因此有权访问 <code>isNaN()</code>、<code>isFinite()</code>、<code>parseInt()</code>、<code>parseFloat()</code> 等方法</li></ol></li><li>document<ol><li><strong>Document 对象</strong>是是window对象的一个属性，因此可以将document对象作为一个全局对象来访问。当浏览器载入 html文档, 它就会成为 <strong>Document 对象</strong>。</li><li>打开控制台输入 document，然后我们就看到了一个document对象，既然是对象，输入 typeof document, 控制打印了 &quot;object&quot;</li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="null和undefined区别"></a>null和undefined区别<a class="hash-link" href="#null和undefined区别" title="Direct link to heading">#</a></h2><ul><li><p>null是一个空对象指针，指向的一个空对象</p></li><li><p>undefined是找不到</p></li><li><p>null的使用场景</p><ul><li>作为函数的参数，表示该函数的参数不是对象 ex:send(null,null,null)</li><li>作为对象原型链的终点</li><li>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值</li><li>让一个对象变成垃圾对象</li></ul></li><li><p>undefined的使用场景</p><ul><li>变量被声明了，但没有赋值时，就等于undefined</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined</li><li>对象没有赋值的属性，该属性的值为undefined</li><li>函数没有返回值时，默认返回undefined</li></ul></li><li><p>typeOf检测undefined是undefined，检测null是Object</p></li><li><p>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">null == undefined // true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">null === undefined // false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">null  === null // true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="type-null-为什么是object"></a>type null 为什么是object<a class="hash-link" href="#type-null-为什么是object" title="Direct link to heading">#</a></h2><ul><li><p>是js的一个bug，在最初的js使用的是32位系统，</p></li><li><p><code>js</code>为了性能优化，使用低位来存储变量的类型信息。</p><table><thead><tr><th>数据类型</th><th>机器码标识</th></tr></thead><tbody><tr><td>对象(Object)</td><td>000</td></tr><tr><td>整数</td><td>1</td></tr><tr><td>浮点数</td><td>010</td></tr><tr><td>字符串</td><td>100</td></tr><tr><td>布尔</td><td>110</td></tr><tr><td><code>undefined</code></td><td>-2^31(即全为1)</td></tr><tr><td><code>null</code></td><td>全为0</td></tr></tbody></table><p>在判断数据类型时，是根据机器码低位标识来判断的，而<code>null</code>的机器码标识为全<code>0</code>，而对象的机器码低位标识（前三位）为<code>000</code>。所以<code>typeof null</code>的结果被误判为<code>Object</code>。</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="-和--的区别"></a>&quot;==&quot; 和 &quot;===&quot; 的区别？<a class="hash-link" href="#-和--的区别" title="Direct link to heading">#</a></h2><p>只会对值进行表,===不仅会对值进行比较,还会对数据类型进行比较.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="如何把十进制的02转换成二进制"></a>如何把十进制的0.2转换成二进制？<a class="hash-link" href="#如何把十进制的02转换成二进制" title="Direct link to heading">#</a></h2><ul><li>十进制转二进制：num.toString(2)</li><li>二进制转十进制：parseInt(num, 2)</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="1-2-3mapparseint-的返回值是什么"></a>[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;].map(parseInt) 的返回值是什么？<a class="hash-link" href="#1-2-3mapparseint-的返回值是什么" title="Direct link to heading">#</a></h2><ul><li><p>返回值是 [1,NaN,NaN]</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">var new_array = arr.map(function callback(currentValue, index, array) {  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Return element for new_array  </span></span><span class="token-line" style="color:#393A34"><span class="token plain"> })  </span></span><span class="token-line" style="color:#393A34"><span class="token plain"> parseInt(string, radix)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;].map((item, index) =&gt; {  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return parseInt(item, index)  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">})  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  parseInt(&#x27;1&#x27;, 0)  1  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  parseInt(&#x27;2&#x27;, 1)  NaN  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  parseInt(&#x27;3&#x27;, 2)  NaN</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>正确的</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function parseIntFun(item) {  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  return parseInt(item, 10)  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;].map(parseIntFun)  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  parseInt(&#x27;1&#x27;, 10)  1  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  parseInt(&#x27;2&#x27;, 10)  2  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">//  parseInt(&#x27;3&#x27;, 10)  3</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="说说你对newtarget的理解"></a>说说你对new.target的理解<a class="hash-link" href="#说说你对newtarget的理解" title="Direct link to heading">#</a></h2><ul><li><p><code>new.target</code>属性允许你检测函数或构造方法是否是通过new运算符被调用的。</p></li><li><p>在通过new运算符被初始化的函数或构造方法中，<code>new.target</code>返回一个指向构造方法或函数的引用。在普通的函数调用中，<code>new.target</code> 的值是undefined。</p></li><li><p>我们可以使用它来检测，一个函数是否是作为构造函数通过new被调用的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function Foo() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (!new.target) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw &quot;Foo() must be called with new&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&quot;Foo instantiated with new&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Foo(); // throws &quot;Foo() must be called with new&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">new Foo(); // logs &quot;Foo instantiated with new&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="typeoftypeof-和instanceof-的区别"></a>typeof(typeof()) 和instanceof 的区别?<a class="hash-link" href="#typeoftypeof-和instanceof-的区别" title="Direct link to heading">#</a></h2><p>typeof可以判断变量的数据类型,返回值是字符串;</p><p>a instanceof b是判断b是不是在a的原型链上, 也可以实现判断数据类型, 返回值为布尔.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="new-fn-和-new-fn-有区别吗"></a>new Fn() 和 new Fn 有区别吗？<a class="hash-link" href="#new-fn-和-new-fn-有区别吗" title="Direct link to heading">#</a></h2><p>用 <code>new</code> 创建构造函数的实例时，通常情况下 <code>new</code> 的构造函数后面需要带括号（譬如：<code>new fn()</code>）。具体的区别要看在什么场景下</p><p>有些情况下<code>new</code>的构造函数后带括号和不带括号的情况一致，譬如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI js"><pre tabindex="0" class="prism-code language-js codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function maybe-class-name" style="color:#d73a49">Fn</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">num</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">Fn</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">//Fn {num:1}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">Fn</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">   </span><span class="token comment" style="color:#999988;font-style:italic">//Fn {num:1}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">复制代码</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>但有些情况下<code>new</code>的构造函数后带括号和不带括号的情况并不一致，譬如：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI js"><pre tabindex="0" class="prism-code language-js codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function maybe-class-name" style="color:#d73a49">Fn</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">num</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">Fn</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">num</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 1</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">Fn</span><span class="token class-name punctuation" style="color:#393A34">.</span><span class="token class-name">num</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 报错</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">复制代码</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>结果分析：</p><ul><li>从报错信息来看，<code>new Fn.num</code>执行顺序是这样的：先执行<code>Fn.num</code>，此时返回结果为<code>undefined</code>；后执行<code>new</code>，因<code>new</code>后面必须跟构造函数，所以<code>new undefined</code>会报错。</li><li><code>new Fn().num</code>相当于<code>(new Fn()).num</code>，所以结果返回1。</li></ul><p>从结果来看，<code>new Fn.num</code>代码相当于<code>new (Fn.num)</code>，<code>new Fn().num</code>相当于<code>(new Fn()).num</code>。由此看来 <code>new</code> 的构造函数后跟括号优先级会提升。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="offsetwidthoffsetheightclientwidthclientheight与scrollwidthscrollheight的区别"></a>offsetWidth/offsetHeight，clientWidth/clientHeight与scrollWidth/scrollHeight的区别？<a class="hash-link" href="#offsetwidthoffsetheightclientwidthclientheight与scrollwidthscrollheight的区别" title="Direct link to heading">#</a></h2><p><strong>offsetWidth/offsetHeight</strong> 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。</p><p>offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。</p><p>offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。</p><p>clientTop 返回的是上边框的宽度。</p><p>clientLeft 返回的左边框的宽度。</p><p><strong>clientWidth/clientHeight</strong> 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。</p><p><strong>scrollWidth/scrollHeight</strong> 返回值包含 content + padding + 溢出内容的尺寸。</p><p>scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。</p><p>scrollLeft 属性返回的是元素滚动条到元素左边的距离。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="什么是polyfill"></a>什么是Polyfill？<a class="hash-link" href="#什么是polyfill" title="Direct link to heading">#</a></h2><p>Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</p><p>比如说 <code>querySelectorAll</code> 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="settimeout为什么不能保证能够及时运行"></a>setTimeout为什么不能保证能够及时运行？<a class="hash-link" href="#settimeout为什么不能保证能够及时运行" title="Direct link to heading">#</a></h2><blockquote><p>主线程从任务队列中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop。</p></blockquote><p>setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。</p><p>浏览器的JS引擎遇到setTimeout，拿走之后不会立即放入异步队列，同步任务执行之后，timer模块会到设置时间之后放到异步队列中。js引擎发现同步队列中没有要执行的东西了，即运行栈空了就从异步队列中读取，然后放到运行栈中执行。所以setTimeout可能会多了等待线程的时间。</p><p>这时setTimeout函数体就变成了运行栈中的执行任务，运行栈空了，再监听异步队列中有没有要执行的任务，如果有就继续执行，如此循环，就叫Event Loop。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="js中函数有哪些调用方式"></a>js中函数有哪些调用方式?<a class="hash-link" href="#js中函数有哪些调用方式" title="Direct link to heading">#</a></h2><p>自调用，new调用，执行上下文调用，回调函数</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="列举和数组操作相关的方法"></a>列举和数组操作相关的方法<a class="hash-link" href="#列举和数组操作相关的方法" title="Direct link to heading">#</a></h2><p>push:将元素添加到数组的末尾, 返回值是数组长度，修改</p><p>pop:将数组最后一个元素弹出, 返回值是被弹出的元素，修改</p><p>unshift:在数组的开头插入一个元素,返回值是数组的长度，修改</p><p>shift:将数组第一个元素弹出,返回值是被弹出的元素，修改</p><p>splice(index,len):删除数组中指定元素修改</p><p>reverse: 翻转数组修改</p><p>sort：数组排序，修改</p><p>concat:连接数组,不修改</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="列举和字符串操相关的方法"></a>列举和字符串操相关的方法<a class="hash-link" href="#列举和字符串操相关的方法" title="Direct link to heading">#</a></h2><p>substr(start,len)/substring(start,end): 截取字符串</p><p>slice:从数组会字符串中截取一段</p><p>indexOf/lastIndexOf:查找某一个字符是否存在于另外一个字符串中, 存在则返回索引, 不存在则返回-1;indexOf是从前向后顺序查找;lastIndexOf是从后向前查找</p><p>replace:替换字符串特定的字符</p><p>toUpperCase:将字符串转成大写</p><p>toLowerCase:将字符串转成小写</p><p>charAt:获取字符串中指定索引的字符</p><p>split，返回数组</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="documenwrite和-innerhtml的区别"></a>documen.write和 innerHTML的区别?<a class="hash-link" href="#documenwrite和-innerhtml的区别" title="Direct link to heading">#</a></h2><p>document.write是指定在整个页面区域的内容, innerHTML是指定某一个元素的内容.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="分别阐述splitslicesplicejoin"></a>分别阐述split(),slice(),splice(),join()？<a class="hash-link" href="#分别阐述splitslicesplicejoin" title="Direct link to heading">#</a></h2><p>split的可以使用一个字符串切割另外一个字符串, 返回值是数组;</p><p>slice可以从数组中截取一部分(字符串对象也有slice方法);</p><p>splice(index,len)可以删除指定的数组元素;</p><p>join可以将数组元素使用特定的连接符拼接成字符串</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="例举-3-中强制类型转换和-2-中隐式类型转换"></a>例举 3 中强制类型转换和 2 中隐式类型转换？<a class="hash-link" href="#例举-3-中强制类型转换和-2-中隐式类型转换" title="Direct link to heading">#</a></h2><p>强制转换:</p><p>转化成字符串 toString() String() 转换成数字 Number()、 parseInt()、 parseFloat();Boolean（）</p><p>隐式转换:</p><p>转换成布尔类型 Boolean() 隐式拼接字符串 </p><p>例子 var str = &quot;&quot; + - / % ===</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="如何判断一个变量foo是数组"></a>如何判断一个变量foo是数组?<a class="hash-link" href="#如何判断一个变量foo是数组" title="Direct link to heading">#</a></h2><ol><li>foo instanceof Array</li><li>foo.constructor == Array</li><li>Array.isArray(foo)</li><li>Object.prototype.toString.call(foo)slice(8,-1) === &quot;Array&quot;</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="知道的网页制作会用到的图片格式有哪些"></a>知道的网页制作会用到的图片格式有哪些？<a class="hash-link" href="#知道的网页制作会用到的图片格式有哪些" title="Direct link to heading">#</a></h2><ol><li>png-8，png-24，jpeg，gif，svg。</li><li>但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp。（是否有关注新技术，新鲜事物）</li><li>科普一下Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。</li><li>在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="关于数据传递问题"></a>关于数据传递问题<a class="hash-link" href="#关于数据传递问题" title="Direct link to heading">#</a></h3><ul><li>在js调用函数时传递变量参数时, 是值传递还是引用传递?</li><li>只有值传递, 没有引用传递, 传递的都是变量的值, 只是这个值可能是基本数据, 也可能是地址(引用)数据</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="0102为什么不等于03"></a>0.1+0.2为什么不等于0.3<a class="hash-link" href="#0102为什么不等于03" title="Direct link to heading">#</a></h2><p><a href="https://blog.csdn.net/flyersboy/article/details/117480157" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/flyersboy/article/details/117480157</a></p><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成 0.30000000000000004</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="foreach有中断效果吗如何中断foreach循环"></a>forEach有中断效果吗？如何中断forEach循环？<a class="hash-link" href="#foreach有中断效果吗如何中断foreach循环" title="Direct link to heading">#</a></h2><p>在<code>forEach</code>中用<code>return</code>不会返回，函数会继续执行。 <strong>中断方法</strong></p><ul><li>使用<code>try</code>监视代码块，在需要中断的地方抛出异常。</li><li>官方推荐方法（替换方法）：用<code>every</code>和<code>some</code>替代<code>forEach</code>函数。<ul><li><code>every</code> 在碰到<code>return false</code>的时候，终止循环。</li><li><code>some</code> 在碰到<code>return true</code>的时候，终止循环。</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="函数声明和函数表达式的区别"></a>函数声明和函数表达式的区别<a class="hash-link" href="#函数声明和函数表达式的区别" title="Direct link to heading">#</a></h2><ol><li>函数什么行在程序运行之前就已将存在，会变量提升</li><li>函数表达式不会提升，只提升那个变量</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="浏览器渲染原理解析"></a>浏览器渲染原理解析<a class="hash-link" href="#浏览器渲染原理解析" title="Direct link to heading">#</a></h2><p>1、首先渲染引擎下载HTML，解析生成DOM Tree</p><p>2、遇到css标签或JS脚本标签就新起线程去下载他们，并继续构建DOM。（其中css是异步下载同步执行）浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建 Rendering Tree</p><p>3、 通过 CSS Rule Tree 匹配 DOM Tree 进行定位坐标和大小，这个过程称为 Flow 或 Layout 。</p><p>4、最终通过调用Native GUI 的 API 绘制网页画面的过程称为 Paint 。</p><p>当用户在浏览网页时进行交互或通过 js 脚本改变页面结构时，以上的部分操作有可能重复运行，此过程称为 Repaint 或 Reflow。 重排是指dom树发生结构变化后，需要重新构建dom结构。 重绘是指dom节点样式改变，重新绘制。 重排一定会带来重绘，重绘不一定有重排。</p><p>如何减少浏览器重排：将需要多次重排的元素，position属性设为absolute或fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="一个页面上有大量的图片大型电商网站加载很慢你有哪些方法优化这些图片的加载给用户更好的体验"></a>一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验<a class="hash-link" href="#一个页面上有大量的图片大型电商网站加载很慢你有哪些方法优化这些图片的加载给用户更好的体验" title="Direct link to heading">#</a></h2><p>图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</p><p>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</p><p>如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。</p><p>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</p><p>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="一个满屏-品-字布局-如何设计"></a>一个满屏 品 字布局 如何设计?<a class="hash-link" href="#一个满屏-品-字布局-如何设计" title="Direct link to heading">#</a></h2><p> 简单的方式：</p><p>  上面的div宽100%，</p><p>  下面的两个div分别宽50%，</p><p>  然后用float或者inline使其不换行即可</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="li与li之间有看不见的空白间隔是什么原因引起的有什么解决办法"></a>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法<a class="hash-link" href="#li与li之间有看不见的空白间隔是什么原因引起的有什么解决办法" title="Direct link to heading">#</a></h2><p>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="为什么要初始化css样式"></a>为什么要初始化CSS样式<a class="hash-link" href="#为什么要初始化css样式" title="Direct link to heading">#</a></h2><p> 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="css多列等高如何实现"></a>css多列等高如何实现？<a class="hash-link" href="#css多列等高如何实现" title="Direct link to heading">#</a></h2><p>利用padding-bottom|margin-bottom正负值相抵；</p><p> 设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度，</p><p> 当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度，</p><p> 其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="怎么让chrome支持小于12px-的文字"></a>怎么让Chrome支持小于12px 的文字？<a class="hash-link" href="#怎么让chrome支持小于12px-的文字" title="Direct link to heading">#</a></h2><p> 1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</p><p> 2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。</p><p> 3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。</p><p> 4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="什么是回调函数"></a>什么是回调函数<a class="hash-link" href="#什么是回调函数" title="Direct link to heading">#</a></h2><ul><li>你定义的</li><li>你没有直接调用</li><li>但最终它执行了(在特定条件或时刻)</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="描述一下对象销毁的方法"></a>描述一下对象销毁的方法<a class="hash-link" href="#描述一下对象销毁的方法" title="Direct link to heading">#</a></h2><ul><li>如果包含对象引用地址的变量是局部变量<ul><li>局部作用域的变量在函数执行完成的时候会自动销毁</li><li>变量销毁以后，对象就没有被变量所引用（此时对象已经不可能再被使用），此时对象就会变成垃圾对象</li><li>垃圾对象会等待回收</li></ul></li><li>如果包含对象引用地址的变量是全局变量<ul><li>全局变量只有等待浏览器关闭才能销毁</li><li>所以此时不用的对象一直被引用，会占用空间</li><li>把变量主动设置为null，对象就没有被引用了，就变成了垃圾对象</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈-call-apply-bind"></a>谈一谈 call apply bind<a class="hash-link" href="#谈一谈-call-apply-bind" title="Direct link to heading">#</a></h2><ul><li>这三个函数的存在意义是<strong>改变函数执行时的上下文</strong>，再具体一点就是<strong>改变函数运行时的this指向</strong>。</li><li>call和apply功能一样，都是调用某个函数并改变函数的this指向</li><li>区别是参数不同，call以参数列表形式传参，apply以数组形式传参</li><li>bind不会调用函数，改变this指向后会返回一个新的函数的引用</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="1-2-3mapparseint-答案是多少"></a>[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案是多少？<a class="hash-link" href="#1-2-3mapparseint-答案是多少" title="Direct link to heading">#</a></h2><ol><li><p>是<code>[1, NaN, NaN]</code><a href="https://juejin.cn/post/6844904089059344398" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904089059344398</a></p></li><li><p><code>parseInt</code> <code>parseInt(string, radix)</code>将一个字符串 <code>string</code> 转换为 <code>radix</code> 进制的整数， <code>radix</code> 为介于2-36之间的数。最后都是以十进制形式返回。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">parseInt(&#x27;1&#x27;, 0) // 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">parseInt(&#x27;2&#x27;, 1) // NaN</span></span><span class="token-line" style="color:#393A34"><span class="token plain">parseInt(&#x27;3&#x27;, 2) // NaN</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p><code>parseInt(&#x27;1&#x27;, 0) // 1</code>如果radix没有指定或者是为0，参数会被假定一10为基数来解析，以字符0X0x开头，会假定一十六进制来解析</p></li><li><p><code>parseInt(&#x27;3&#x27;, 2) // NaN</code>二进制没有3这个数,同理<code>parseInt(&#x27;2&#x27;, 1) // NaN</code></p></li><li><p>如果第一个参数<code>string</code>的第一个值就大于等于第二个参数<code>radix</code>，那么直接返回<code>NaN</code></p></li><li><p>如果第一个参数<code>string</code>的第一个值符合条件，其他值不符合条件，那么不符合条件的值到最后会被忽略，然后进行计算</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="什么是事件ie与火狐的事件机制有什么区别-如何阻止冒泡"></a>什么是事件？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？<a class="hash-link" href="#什么是事件ie与火狐的事件机制有什么区别-如何阻止冒泡" title="Direct link to heading">#</a></h2><ol><li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</li><li>事件处理机制：I.E.是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；</li><li>ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="javascript中有一个函数执行时对象查找时永远不会去查找原型这个函数是"></a>Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？<a class="hash-link" href="#javascript中有一个函数执行时对象查找时永远不会去查找原型这个函数是" title="Direct link to heading">#</a></h2><ol><li><code>hasOwnProperty</code></li><li><code>JS</code>中的<code>hasOwnProperty</code>函数方法是返回一个布尔值，指出一个对象是否具有指定的名称的属性。此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员</li><li><code>object.hasOwnProperty(proName)</code></li><li><code>proName</code>是必选项，一个属性名称的字符串值</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="json了解吗"></a>JSON了解吗<a class="hash-link" href="#json了解吗" title="Direct link to heading">#</a></h2><ol><li><p>定义：JSON是一种轻量级的数据交换模式</p></li><li><p>它是基于JS的一个子集。数据格式简单，易于读写，占用带宽小</p></li><li><p>方法</p><ol><li><p>JS对象-》json字符串</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">JSON.stringify()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>json字符串转换为JS对象</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">JSON.parse()</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="js延迟加载的方式有哪些"></a>js延迟加载的方式有哪些？<a class="hash-link" href="#js延迟加载的方式有哪些" title="Direct link to heading">#</a></h2><ol><li><p>defer和async</p><ol><li><p>在默认情况下，网页都是同步加载外部 JavaScript文件的，在引入外部js文件时会阻塞dom的执行</p></li><li><p>defer相当于告诉浏览器立即下载，但是延迟执行</p></li><li><p>如果页面中有多个延迟脚本，那么第一个延迟脚本会先于第二个延迟脚本执行，而这些脚本会先于DOMContentLoaded事件执行</p></li><li><p>async，即表示应该立即下载脚本，但不应妨碍页面汇总的其它操作。只对外部脚本文件有效。</p><p><img src="C:%5CUsers%5Cpc%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201223230014464.png" alt="image-20201223230014464"></p></li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="如何判断当前脚本运行在浏览器还是node中"></a>如何判断当前脚本运行在浏览器还是NODE中？<a class="hash-link" href="#如何判断当前脚本运行在浏览器还是node中" title="Direct link to heading">#</a></h2><p> 通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="split-join-的区别"></a>split() 、join() 的区别<a class="hash-link" href="#split-join-的区别" title="Direct link to heading">#</a></h2><p>前者是切割成数组的形式，后者是将数组转换成字符串</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="哪一些操作会造成内存泄漏"></a>哪一些操作会造成内存泄漏<a class="hash-link" href="#哪一些操作会造成内存泄漏" title="Direct link to heading">#</a></h2><ol><li>内存泄漏就是指任何对象在您不再拥有或需要它之后仍然存在。</li><li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</li><li>造成内存泄漏的操作<ol><li>全局变量：JavaScript中的全局变量是由根节点（root node）引用的，因此它们在应用程序的整个生命周期中都不会被垃圾回收。<ol><li>解决：使用严格模式，尽量少创建一些全局变量</li></ol></li><li>计时器</li><li>多出引用</li><li>闭包</li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="javascript本地存储的方式有哪些有什么区别以及有哪些应用场景"></a>JavaScript本地存储的方式有哪些，有什么区别，以及有哪些应用场景？<a class="hash-link" href="#javascript本地存储的方式有哪些有什么区别以及有哪些应用场景" title="Direct link to heading">#</a></h2><p>javaScript本地缓存的方式主要有以下四种：</p><ol><li>localStorage：不可以设置过期时间<ul><li>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li><li>存储的信息在同一域中是共享的</li><li>当本页操作（新增、修改、删除）了<code>localStorage</code>的时候，本页面不会触发<code>storage</code>事件,但是别的页面会触发<code>storage</code>事件。</li><li>大小：5M（跟浏览器厂商有关系）</li><li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li>受同源策略的限制</li></ul></li><li>sessionStorage：页面（会话）关闭，<code>sessionStorage</code> 将会删除数据</li><li>cookie：4KB,可以设置过期时间</li><li>indexedDB</li></ol><p>关于<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>三者的区别主要如下：</p><ul><li>存储大小：<code>cookie</code>数据大小不能超过<code>4k</code>，<code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li><li>有效时间：<code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； <code>sessionStorage</code>数据在当前浏览器窗口关闭后自动删除；<code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li><li>数据与服务器之间的交互方式，<code>cookie</code>的数据会自动的传递到服务器，服务器端也可以写<code>cookie</code>到客户端； <code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li></ul><p>它们的区别和应用场景，点击前往：<a href="https://juejin.cn/post/7158272097897152525" target="_blank" rel="noopener noreferrer"># 关于JavaScript的本地存储方案</a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="promise中resolve后面的语句是否还会执行"></a>Promise中，resolve后面的语句是否还会执行？<a class="hash-link" href="#promise中resolve后面的语句是否还会执行" title="Direct link to heading">#</a></h2><p>会被执行。如果不需要执行，需要在 resolve 语句前加上 return。</p><header><h1><code>JS</code>高级</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈谈你对-this-指向的理解"></a>谈谈你对 this 指向的理解？<a class="hash-link" href="#谈谈你对-this-指向的理解" title="Direct link to heading">#</a></h2><ol><li>this是函数中的一个变量，他指向的对象是根据函数调用时候决定的<ol><li>首先确实是否是硬绑定，如果是则this指向call所规定的对象</li><li>是否是实例化调用，如果是实例化调用，则this指向实例化对象</li><li>判断函数调用是否是被上下文对象调用的，如果是 则this指向上下文对象（要注意是否存在隐式丢失现象）</li><li>函数自调用 返回window，在ES5的严格模式下，this指向的是undefined</li><li>箭头函数没有this（箭头函数的this是它外层函数的this指向）</li><li>vue中的this指向组件实例对象</li><li>react<ol><li>普通事件回调函数 undefined，使用babel编译后是严格模式</li><li>箭头函数 组件实例对象</li></ol></li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈箭头函数"></a>谈一谈箭头函数<a class="hash-link" href="#谈一谈箭头函数" title="Direct link to heading">#</a></h2><ol><li><p>没有自己的 this，指向它外层全局/函数作用域指向的 this</p></li><li><p>没有自己的 arguments，指向它外层全局/函数作用域指向的 arguments</p></li><li><p>箭头函数没有显示原型属性，不能被 new 调用
箭头函数有隐式原型属性，可以 call/apply 等方法，但是没有意义</p></li><li><p>写法</p><p>1.只有一个参数，并且函数体只有一个return，参数写在 =&gt;前   函数体写在=&gt;后  如果函数体只有一个return  则直接书写return后的语句 并且省略大括号
2.函数多个形参 或者没有形参，使用括号括起来
3.当函数体有多句话 需要书写完整的函数体，使用大括号括起来</p></li><li><p>如何控制函数的this? </p><ol><li>利用函数的bind()</li><li>利用箭头函数</li><li>也可以用外部保存了this的变量</li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="new-关键字内部做了什么"></a>new 关键字内部做了什么？<a class="hash-link" href="#new-关键字内部做了什么" title="Direct link to heading">#</a></h2><ol><li>先创建一个空对象，最后会返回这个对象</li><li>调用构造函数，并将构造函数的this指向新创建的空对象</li><li>把新创建的对象的<strong>proto</strong>指向构造函数的显式原型</li><li>判断构造函数的返回值，来决定new的返回值是（构造函数的返回值还是实例化对象）</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈谈你对原型的理解"></a>谈谈你对原型的理解？<a class="hash-link" href="#谈谈你对原型的理解" title="Direct link to heading">#</a></h2><ol><li><p>什么是原型</p><ol><li>原型指的是两个原型属性：<code>prototype(显示原型属性) 和 proto(隐式原型属性)</code></li></ol></li><li><p><code>prototype(显示原型属性)</code></p><ol><li>每一个函数都有自己的显式原型（prototype属性）</li><li>函数只有在使用的时候如果是new调用 才是一个构造函数</li><li>显示原型（prototype其实是一个指针）指向的是 当前函数的原型对象，默认是空对象</li><li>每一原型对象都有一个constructor属性，指向当前原型对象的构造函数</li></ol></li><li><p><code>proto(隐式原型属性)</code></p><ol><li>所有的实例对象都有<strong>proto</strong>属性, 它指向的就是原型对象</li><li>这样通过<strong>proto</strong>属性就形成了一个链的结构----&gt;原型链</li><li>当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找，找不到就会报undefined</li><li>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</li><li>所有函数都是<code>Function()</code>的实例化对象，所有原型对象都是<code>Object()</code>的实例化对象）</li><li><code>Function</code>是<code>new Function</code>出来的，Object的原型对象的隐式原型是null</li><li>Object和Function两个构造函数是本身就有的，Object的<strong>proto</strong>指向Function的原型对象，因为Object可以使用call方法。</li></ol></li><li><p>原型链的作用：用来查找属性/方法</p></li><li><p>作用：通过继承的方式来复用代码</p></li><li><p>vue中我们使用的全局事件总线</p><p><img src="https://raw.githubusercontent.com/Minyym/figure-bed/master/img/202302221831585.png"></p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈闭包"></a>谈一谈闭包<a class="hash-link" href="#谈一谈闭包" title="Direct link to heading">#</a></h2><ol><li><p>定义：通过 chrome 调试查看，一个包含内部函数引入外部函数变量的对象，closure</p></li><li><p>产生时间： 执行内部函数定义(创建函数对象)后</p></li><li><p>闭包的产生条件</p><ol><li>函数嵌套</li><li>内部函数引用外部函数的局部变量</li><li>执行外部函数</li></ol></li><li><p>闭包的优点</p><ol><li>延长函数局部变量存活时间(生命周期)</li><li>让函数外部操作（读/写）函数内部的数据</li></ol></li><li><p>闭包的生命周期</p><ol><li>产生：内部函数定义执行完了</li><li>死亡：当内部函数成为垃圾对象（内部函数没有任何变量引用），自动被垃圾回收机制回收释放</li></ol></li><li><p>闭包的缺点</p><p>容易导致内存泄漏
内存泄漏：占用了内存空间，没有及时释放
内存溢出：将要使用内存超过了实际内存（程序会直接崩溃）
解决：及时释放
目的：当保存闭包内部函数成为垃圾对象 fn = null;</p></li><li><p>闭包的应用</p><p>高阶函数（执行函数返回值新函数） --&gt; React
框架/库底层源码 --&gt; Vue，this会使用给一个变量进行接收，然后使用</p><p>react的函数科里化</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈谈你对-promise-的理解"></a>谈谈你对 promise 的理解？<a class="hash-link" href="#谈谈你对-promise-的理解" title="Direct link to heading">#</a></h2><ol><li><p>promise 对象是一个异步编程解决方案，用来解决异步回调地狱问题方案</p></li><li><p>promise 对象有三种状态：代表异步执行的状态</p><ol><li>pending 初始化状态（异步代码还在执行中）</li><li>resolved / fulfilled 成功状态（异步代码执行成功了）</li><li>rejected 失败状态（异步代码执行失败了）</li></ol></li><li><p>当你创建 promise 对象，默认为 pending</p><ol><li>resolve 调用 resolve 函数，可以将 promise 对象的状态由 pending 变成 resolved</li><li>reject 调用 reject 函数，可以将 promise 对象的状态由 pending 变成 rejected</li></ol></li><li><p>注意：promise 的状态只能修改一次</p></li><li><p>promise的方法</p><ol><li><code>Promise.prototype.then</code>捕获成功的promise对象</li><li><code>Promise.prototype.catch</code>用来捕获失败的promise对象</li><li><code>Promise.all([promise1, ...]) </code> 传入 n 个 promise 对象，只有 n 个 promise 对象的状态都成功，才成功，只要有一个失败，就失败，它的PromiseValue的值是一个数组，保存的是all方法中所有promise对象resolve的输出的值</li><li><code>Promise.allSettled([promise1, ...])</code>传入 n 个 promise 对象，等 n 个 promise 对象状态全部发生变化，得到所有结果值，PromiseValue就是一个数组，包含了方法内返回的所有promise对象</li><li><code>Promise.resolve()</code> 返回一个成功状态 promise 对象</li><li><code>Promise.reject()</code>返回一个失败状态 promise 对象</li><li><code>race </code>返回promise对象，promise对象的状态是race中第一个执行完成的那个promise的状态（无论成功还是失败）</li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈谈你对-async-函数的理解"></a>谈谈你对 async 函数的理解？<a class="hash-link" href="#谈谈你对-async-函数的理解" title="Direct link to heading">#</a></h2><ol><li>async 函数是一个解决异步编程的方案，最好用的方案</li><li>本质上是 generator 语法糖</li><li>async 取代 *
await 取代 yield</li><li>await 只会等 promise 对象<ol><li>如果 promise 对象是 pending 状态 就一直等</li><li>如果 promise 对象是 resolved 状态 就会执行后面代码</li><li>如果 promise 对象是 rejected 状态 就会退出当前 async 函数</li></ol></li><li>执行 async 函数返回值是一个 promise 对象<ol><li>全部执行完就是 resolved 状态</li><li>内部 promise 对象是 rejected 状态或者内部报错了，就是 rejected 状态</li><li>代码还未执行完，就是 pending</li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="浏览器事件轮询机制谈谈完整异步代码的执行机制从浏览器到-nodejs"></a>（浏览器事件轮询机制）谈谈完整异步代码的执行机制（从浏览器到 nodejs）?<a class="hash-link" href="#浏览器事件轮询机制谈谈完整异步代码的执行机制从浏览器到-nodejs" title="Direct link to heading">#</a></h2><ol><li>浏览器事件轮询机制<ol><li>JS执行代码的顺序</li><li>现在执行同步代码，在去执异步代码</li><li>流程：<ol><li>JS引擎会从上到下执行代码，同步代码依次执行，把响应的回调函数放到对应的事件管理模块（DOM 事件放在DOM 事件管理模块，定时器放在定时器管理模块）</li><li>事件发生或计时器到期时，管理模块会将回调函数及其数据添加到回调列队中</li><li>等初始化代码执行完毕，js引擎就会循环的检查回调队列中的回调函数，并执行</li></ol></li></ol></li><li>nodejs轮训机制（说微任务优先是没有算上script标签是宏任务，初始化的时候从前面开始轮回，再次更新的时候的，是从poll开始，最终停在了poll队列，之所以停在poll阶段，是因为要I/O任务，读文件，停在这里，有了就先处理它）<ol><li>.nodeJS使用了第三方库libuv，nodeJS会把一些异步操作（I/O、文件的读写）交给libuv处理。nodejs的主线程没有必要等待，可以继续处理其他事情。</li><li>libuv会开启多个线程去执行这些异步操作，当异步代码操作完毕以后，会把回调函数放到回调队列中，主线程在适当的时候回去轮询回调队列。</li><li>nodejs把所有的异步操作代码分为了微任务代码和宏任务代码</li><li>nodejs会优先执行微任务代码，然后才执行宏任务代码</li><li>微任务：process.nextTick，Promise的then\catch\finally、queueMicrotask</li><li>process.nextTick一定是最先执行，其他微任务根据书写代码依次执行</li><li>在宏任务每次执行下一个阶段之前，都会去检查微任务队列中是否有微任务需要执行，然后才会执行下一个阶段</li><li>宏任务的轮询顺序<ol><li>timers阶段：处理setTimeout和setInterval的回调函数</li><li>pedding阶段：处理系统级别操作的回调函数</li><li>idle阶段：处理nodejs内部的回调函数</li><li>poll阶段：处理I/O或者网络请求等异步操作的回调函数<ol><li>当poll阶段不为空的时候，那么执行完回调函数，就继续执行下个阶段check了</li><li>当poll阶段为空，会一直等待poll中有其他的回调函数</li><li>当时当 timer阶段的计时器到期了，或者check阶段有setImmediate等待执行的时候，会直接进入check阶段</li></ol></li><li>check阶段：setImmediate的回调函数</li><li>close阶段：执行一些关闭的函数</li></ol></li></ol></li><li>H5新的MutationObserver也基于event loop   ==&gt; 微任务</li><li>Promise的.then不是webAPI，没有时间管理模块</li><li>webApi是DOM和BOM(W3C)</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈继承"></a>谈一谈继承<a class="hash-link" href="#谈一谈继承" title="Direct link to heading">#</a></h2><ol><li><p>ES5继承</p><ol><li><p>组合继承，this和原型链继承</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">function Animal(name, age) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.name = name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.age = age;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Animal.prototype.say = function () {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;吼~&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">function Cat(color, name, age) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.color = color;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //构造函数继承</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Animal.call(this, name, age)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//原型链继承</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cat.prototype = new Animal();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//修正constructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Cat.prototype.constructor = Cat;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">var cat1 = new Cat(&quot;white&quot;, &quot;wanAn&quot;, &quot;2&quot;);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>子类的原型对象为什么指向实例对象，因为直接指向父类的原型对象，指向的就是同一个地址，子类就修改父类的数据，子类是不能修改父类上的数据，所以指向实例对象，也可以找到，父类的原型对象，最后修正constructor</p></li><li><p>例如：Vue、VueComponent，Array和Object</p></li></ol></li><li><p>ES6使用extend继承，是ES5的语法糖</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class Person {       </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        constructor(name, age) {               </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.name = name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.age = age;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }           </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eat() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            console.log(&quot;吃饭&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        sex = &quot;男&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        static hi = &quot;hello&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Person.prototype.drink = function () {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        console.log(&quot;大乌苏&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //定义一个Student类 继承 Person类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    class Student extends Person {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        constructor(project, name, age) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // ES6中继承的子类中，如果使用构造函数constructor()那么就必须使用super()方法初始化，这样下面才可以调用this关键字。super()只能用在子类的构造函数之中，用在其他地方就会报错,这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // super=&gt;Person2.prototype  super.sayHello()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            super(name, age);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.project = project;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        study() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            console.log(&quot;我最喜欢ES6了&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>区别</p><ol><li>ES5 的继承是通过原型或者是构造函数来实现</li><li>ES6 用过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现，子类必须 在 constructor 方法中调用 super 方法</li></ol></li><li><p>应用</p><ol><li>react的类组件</li><li>vue的VueComponent</li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈谈callapplybind"></a>谈谈call/apply/bind<a class="hash-link" href="#谈谈callapplybind" title="Direct link to heading">#</a></h2><ol><li>这三个方法都是函数这个特殊对象的方法,通过这三个方法都可以改变函数内部this的指向</li><li>call和apply会调用一次函数, 而bind不会调用函数, 返回一个新的函数</li><li>call和apply传参的形式不同<ol><li>call的参数是一个参数列表</li><li>apply是一个数组</li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="说一下事件委托"></a>说一下事件委托<a class="hash-link" href="#说一下事件委托" title="Direct link to heading">#</a></h2><ol><li>定义：将事件注册给父元素</li><li>原理：事假冒泡，字元素的事件会向外冒泡，触发父级的相同事件，可以根据事件对象可以找到触发事件的目标元素</li><li>事件委托有什么好处
1.减少绑定的监听数
2.减少了内存的开销
3.一劳永逸,后续新增的子节点也可以享受到之前绑定的事件委托</li><li>触发者	最内层的子元素	event.target
事件源	绑定事件的元素	this</li><li>小程序
触发者	最内层的子元素	event.target
事件源	绑定事件的元素	this不行了,他存放的是当前页面实例,event.currentTarget可以获取到当前事件源</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈作用域链"></a>谈一谈作用域链<a class="hash-link" href="#谈一谈作用域链" title="Direct link to heading">#</a></h2><p>作用域：是变量在程序中可以访问的有效范围</p><ol><li>函数的创建的时候，会创建一条作用域链</li><li>作用域链的用途,是保证对  当前执行环境<strong>有权访问</strong>的所有变量和函数的  <strong>有序访问</strong>。</li><li>作用域链访问的所有的变量和函数， 也就是访问的是各个函数变量对象，其实真正意义上是一个各个作用域的变量对象组成的链条</li><li>在函数定义的时候，创建的作用域链式不完整的，因为当前的函数没有执行，所以作用域链的最前端没有变量对象</li><li>当函数调用并创建执行上下文的时候，会把当前的作用域的变量对象放到作用域链的最前端，此时作用域链完整并激活</li><li>作用域链的前端,始终都是当前执行的代码所在环境的变量对象。最末端一定是window对象</li><li>当查找一个变量的时候，就会沿着作用域链去查找，如果查不到就会抛出错误</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="什么是执行上下文"></a>什么是执行上下文<a class="hash-link" href="#什么是执行上下文" title="Direct link to heading">#</a></h2><ol><li>js解析并不是真正的直接逐行解析，而是进入到一个新的作用域的时候，会有一个准备工作，这个准备工作被称作为‘执行上下文’，执行上下文还在内存中为函数执行创建一个空间</li><li>新的作用域可以是全局作用域和局部作用域</li><li>全局的执行上下文只有一个，局部的执行上下文可以有多个</li><li>因为有多个执行上下文，所以js会创建一个执行上下文栈（stack），用来管理所有的执行上下文</li><li>代码最开始指向是先执行全局，所以会现在stack中压入一个全局执行上下文，全局执行上下文等代码全部指向完毕才退出</li><li>当代码执行一个函数，此时就会创建一个新的局部执行上下文，并把它压入到stack中，当函数执行函完毕，就把当前执行上下文在stack中弹出</li><li>执行上下文包含3个内容：1.变量对象  2.确定this  3.激活作用域链</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="谈一谈变量对象"></a>谈一谈变量对象<a class="hash-link" href="#谈一谈变量对象" title="Direct link to heading">#</a></h2><ol><li>变量对象 是 保存当前作用域所有的属性和方法</li><li>在执行上下文中，变量对象被创建和激活，只有变量对象被激活，我们才能获取到当前作用域定义的属性和方法</li><li>变量对象分为 全局变量对象和局部变量对象</li><li>全局的变量对象其实就是window对象，因为所有的全局变量和全局的函数 都是window对象的属性和方法</li><li>局部变量对象：<ol><li>创建局部执行上下文时候产生局部变量对象</li><li>在变量对象中创建形参和实参</li><li>把所有的函数声明放到变量对象中(函数优先提升),此时如果有重名的属性，则直接覆盖</li><li>把当前作用域中所有的变量，以键值对的形式保存在变量对象中，此时所有的变量的值都应该是undefined</li><li>当提升的变量如果和形参或函数有重名的，则不会干扰已经存在的这些属性(只有当执行到变量被赋值了，才会进行覆盖)</li></ol></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="说一下事件轮询机制"></a>说一下事件轮询机制<a class="hash-link" href="#说一下事件轮询机制" title="Direct link to heading">#</a></h2><p>说一下事件轮询机制 	</p><ul><li><p>js执行代码的顺序：</p><ul><li>先执行同步代码</li><li>等待同步代码执行完成后才执行异步代码</li></ul></li><li><p>模型由两个重要内容</p><ul><li><p>事件管理模块</p></li><li><p>回调队列</p></li></ul></li><li><p>执行初始化同步代码，把相应的回调给到浏览器对应的管理模块</p></li><li><p>当事件发生或计时器到期时，管理模块会将回调函数及其数据添加到回调列队中</p></li><li><p>等初始化代码执行完毕，js引擎就会循环的检查回调队列中的回调函数，并执行</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="说一下-进程和线程"></a>说一下 进程和线程<a class="hash-link" href="#说一下-进程和线程" title="Direct link to heading">#</a></h2><ul><li><p>进程是程序的某一次的执行，主要在内存开启一定的空间</p></li><li><p>线程是进程的一个独立单元，是cpu的基本调度单位</p></li><li><p>有的程序是单进程的 有的程序是多进程的（多个进程不可以共享数据）</p></li><li><p>有的进程是单线程，有的进程是多线程（多个线程可以共享数据）</p></li><li><p>单线程：</p><ul><li><p>编程简单</p></li><li><p>效率低</p></li></ul></li><li><p>多线程：</p><ul><li>可以提高CPU的利用率</li><li>创建多个线程的时候会有额外开销</li><li>切换线程的时候也会有额外的开销</li><li>容易产生死锁（活锁、饿死）</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="描述多态和封装"></a>描述多态和封装<a class="hash-link" href="#描述多态和封装" title="Direct link to heading">#</a></h2><ul><li>封装的目的是将信息隐藏，一般来说封装包括封装数据、封装实现，封装实现即隐藏实现细节、设计细节，封装使得对象内部的变化对其他对象而言是不可见的，对象对它自己的行为负责，其他对象或者用户都不关心它的内部实现，使用者只需要知道如何使用即可。</li><li>多态：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果，也就是说，给不同的对象发送同一个消息时，这些对象会根据这个消息分别给出不同的反馈。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="简单描述h5新属性多线程的书写过程"></a>简单描述h5新属性多线程的书写过程<a class="hash-link" href="#简单描述h5新属性多线程的书写过程" title="Direct link to heading">#</a></h2><ul><li>在主线程中<ul><li>创建一个分线程(并且把分线程的js代码传入构造函数中)</li><li>向分线程传输数据（如果不发送也要书写）</li><li>主线程也要书写一个事件，当子线程传输回来数据的时候，会直接触发onmessage事件</li><li>关闭线程</li></ul></li><li>在分线程中<ul><li>onmessage事件用来接收主线程传递过来的数据 数据保存在事件函数的第一个参数上（event对象）</li><li>可以直接使用postmessage把得到数据传送回主线程</li><li>关闭线程</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="事件流"></a>事件流<a class="hash-link" href="#事件流" title="Direct link to heading">#</a></h2><p>事件流就是多个节点对象对同一种事件进行响应的先后顺序,主要包括以下3种类型</p><ul><li><p>冒泡型（IE） 事件从最特定的目标向最不特定的目标( document对象)触发,也就是事件从下向上进行响应,这 个传递过程被形象地称为“冒泡”</p></li><li><p>捕获型(网景) 事件从最不确定的目标（document对象）开始触发，然后到最特定的目标，也就是事件从上向下进行相应</p></li><li><p>混合型 （ECMA）w3C的DOM事件模型支持捕获型和冒泡型两种事件流,其中捕获型事件流先发生,然后才发生冒泡型事件流。两种事件流会触及DOM中的所有层级对象,从 document对象开始,最后返回 document对象结束。因此,可以把事件传播的整个过程分为3个阶段</p><ul><li><strong>捕获阶段</strong>:事件从 document对象沿着文档树向下传播到目标节点,如果目标节点的任何一个上级节点注册了相同的事件,那么事件在传播的过程中就会首先在最接近顶部的上级节点执行,依次向下传播</li><li><strong>目标阶段</strong>:注册在目标节点上的事件被执行</li><li><strong>冒泡阶段</strong>:事件从目标节点向上触发,如果上级节点注册了相同的事件,将会逐级响应,依次向上传播</li></ul></li><li><p>阻止冒泡</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI JS"><pre tabindex="0" class="prism-code language-JS codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">event.stopPropagation();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">event.cancelBubble=true;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="单线程与异步"></a>单线程与异步<a class="hash-link" href="#单线程与异步" title="Direct link to heading">#</a></h2><ol><li>JS是单线程编程语言, 只能同时做一件事</li><li>js引擎是在一个线程(可以称为JS线程)上解析执行js代码的(web worker除外), 无论是同步代码还是异步代码</li><li>界面第一次渲染: 初始化同步代码 ==&gt; 所有的微任务==&gt; <strong>渲染界面</strong>==&gt; 执行第一个宏任务</li><li>界面更新渲染: 所有的微任务==&gt; <strong>渲染界面</strong>==&gt; 执行第一个宏任务</li><li>总结: 清空微队列中所有微任务 ==&gt; 渲染界(UI线程) ==&gt; 执行宏队列中的第一个宏任务</li><li><strong>浏览器</strong>在另一个线程(GUI渲染线程)进行页面渲染操作</li><li>GUI渲染线程与js线程是互斥(不会同时执行), 因为 JS 可以修改 DOM 结构</li><li>遇到需要等待 (网络请求, 定时任务) 不能卡住</li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/Minyym/my-website/edit/master/docs/面试/3.js.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/my-website/docs/面试/dom  bom"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« DOMBOM</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/my-website/docs/面试/es"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">ES5+ »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#const-let-var-的区别" class="table-of-contents__link">const let var 的区别</a></li><li><a href="#执行上下文栈" class="table-of-contents__link">执行上下文栈</a><ul><li><a href="#变量对象" class="table-of-contents__link">变量对象</a></li><li><a href="#作用域链" class="table-of-contents__link">作用域链</a></li><li><a href="#this指向" class="table-of-contents__link">this指向</a></li><li><a href="#this的5种绑定方式" class="table-of-contents__link">this的5种绑定方式</a></li></ul></li><li><a href="#事件循环模型事件轮询机制" class="table-of-contents__link">事件循环模型（事件轮询机制）</a></li><li><a href="#继承" class="table-of-contents__link">继承</a></li><li><a href="#为什么javascript是单线程" class="table-of-contents__link">为什么JavaScript是单线程？</a></li><li><a href="#js的数据类型和变量类型" class="table-of-contents__link">JS的数据类型，和变量类型</a></li><li><a href="#分析基本数据类型和引用数据类型的区别" class="table-of-contents__link">分析基本数据类型和引用数据类型的区别</a></li><li><a href="#为什么一定要分堆和栈两个存储空间呢所有数据直接存放在栈中不就可以了吗" class="table-of-contents__link">为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？</a></li><li><a href="#eval是做什么的" class="table-of-contents__link">eval是做什么的？</a></li><li><a href="#什么是window对象-什么是document对象" class="table-of-contents__link">什么是window对象? 什么是document对象?</a></li><li><a href="#null和undefined区别" class="table-of-contents__link">null和undefined区别</a></li><li><a href="#type-null-为什么是object" class="table-of-contents__link">type null 为什么是object</a></li><li><a href="#-和--的区别" class="table-of-contents__link">&quot;==&quot; 和 &quot;===&quot; 的区别？</a></li><li><a href="#如何把十进制的02转换成二进制" class="table-of-contents__link">如何把十进制的0.2转换成二进制？</a></li><li><a href="#1-2-3mapparseint-的返回值是什么" class="table-of-contents__link">'1', '2', '3'.map(parseInt) 的返回值是什么？</a></li><li><a href="#说说你对newtarget的理解" class="table-of-contents__link">说说你对new.target的理解</a></li><li><a href="#typeoftypeof-和instanceof-的区别" class="table-of-contents__link">typeof(typeof()) 和instanceof 的区别?</a></li><li><a href="#new-fn-和-new-fn-有区别吗" class="table-of-contents__link">new Fn() 和 new Fn 有区别吗？</a></li><li><a href="#offsetwidthoffsetheightclientwidthclientheight与scrollwidthscrollheight的区别" class="table-of-contents__link">offsetWidth/offsetHeight，clientWidth/clientHeight与scrollWidth/scrollHeight的区别？</a></li><li><a href="#什么是polyfill" class="table-of-contents__link">什么是Polyfill？</a></li><li><a href="#settimeout为什么不能保证能够及时运行" class="table-of-contents__link">setTimeout为什么不能保证能够及时运行？</a></li><li><a href="#js中函数有哪些调用方式" class="table-of-contents__link">js中函数有哪些调用方式?</a></li><li><a href="#列举和数组操作相关的方法" class="table-of-contents__link">列举和数组操作相关的方法</a></li><li><a href="#列举和字符串操相关的方法" class="table-of-contents__link">列举和字符串操相关的方法</a></li><li><a href="#documenwrite和-innerhtml的区别" class="table-of-contents__link">documen.write和 innerHTML的区别?</a></li><li><a href="#分别阐述splitslicesplicejoin" class="table-of-contents__link">分别阐述split(),slice(),splice(),join()？</a></li><li><a href="#例举-3-中强制类型转换和-2-中隐式类型转换" class="table-of-contents__link">例举 3 中强制类型转换和 2 中隐式类型转换？</a></li><li><a href="#如何判断一个变量foo是数组" class="table-of-contents__link">如何判断一个变量foo是数组?</a></li><li><a href="#知道的网页制作会用到的图片格式有哪些" class="table-of-contents__link">知道的网页制作会用到的图片格式有哪些？</a><ul><li><a href="#关于数据传递问题" class="table-of-contents__link">关于数据传递问题</a></li></ul></li><li><a href="#0102为什么不等于03" class="table-of-contents__link">0.1+0.2为什么不等于0.3</a></li><li><a href="#foreach有中断效果吗如何中断foreach循环" class="table-of-contents__link">forEach有中断效果吗？如何中断forEach循环？</a></li><li><a href="#函数声明和函数表达式的区别" class="table-of-contents__link">函数声明和函数表达式的区别</a></li><li><a href="#浏览器渲染原理解析" class="table-of-contents__link">浏览器渲染原理解析</a></li><li><a href="#一个页面上有大量的图片大型电商网站加载很慢你有哪些方法优化这些图片的加载给用户更好的体验" class="table-of-contents__link">一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验</a></li><li><a href="#一个满屏-品-字布局-如何设计" class="table-of-contents__link">一个满屏 品 字布局 如何设计?</a></li><li><a href="#li与li之间有看不见的空白间隔是什么原因引起的有什么解决办法" class="table-of-contents__link">li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法</a></li><li><a href="#为什么要初始化css样式" class="table-of-contents__link">为什么要初始化CSS样式</a></li><li><a href="#css多列等高如何实现" class="table-of-contents__link">css多列等高如何实现？</a></li><li><a href="#怎么让chrome支持小于12px-的文字" class="table-of-contents__link">怎么让Chrome支持小于12px 的文字？</a></li><li><a href="#什么是回调函数" class="table-of-contents__link">什么是回调函数</a></li><li><a href="#描述一下对象销毁的方法" class="table-of-contents__link">描述一下对象销毁的方法</a></li><li><a href="#谈一谈-call-apply-bind" class="table-of-contents__link">谈一谈 call apply bind</a></li><li><a href="#1-2-3mapparseint-答案是多少" class="table-of-contents__link">"1", "2", "3".map(parseInt) 答案是多少？</a></li><li><a href="#什么是事件ie与火狐的事件机制有什么区别-如何阻止冒泡" class="table-of-contents__link">什么是事件？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</a></li><li><a href="#javascript中有一个函数执行时对象查找时永远不会去查找原型这个函数是" class="table-of-contents__link">Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？</a></li><li><a href="#json了解吗" class="table-of-contents__link">JSON了解吗</a></li><li><a href="#js延迟加载的方式有哪些" class="table-of-contents__link">js延迟加载的方式有哪些？</a></li><li><a href="#如何判断当前脚本运行在浏览器还是node中" class="table-of-contents__link">如何判断当前脚本运行在浏览器还是NODE中？</a></li><li><a href="#split-join-的区别" class="table-of-contents__link">split() 、join() 的区别</a></li><li><a href="#哪一些操作会造成内存泄漏" class="table-of-contents__link">哪一些操作会造成内存泄漏</a></li><li><a href="#javascript本地存储的方式有哪些有什么区别以及有哪些应用场景" class="table-of-contents__link">JavaScript本地存储的方式有哪些，有什么区别，以及有哪些应用场景？</a></li><li><a href="#promise中resolve后面的语句是否还会执行" class="table-of-contents__link">Promise中，resolve后面的语句是否还会执行？</a></li><li><a href="#谈谈你对-this-指向的理解" class="table-of-contents__link">谈谈你对 this 指向的理解？</a></li><li><a href="#谈一谈箭头函数" class="table-of-contents__link">谈一谈箭头函数</a></li><li><a href="#new-关键字内部做了什么" class="table-of-contents__link">new 关键字内部做了什么？</a></li><li><a href="#谈谈你对原型的理解" class="table-of-contents__link">谈谈你对原型的理解？</a></li><li><a href="#谈一谈闭包" class="table-of-contents__link">谈一谈闭包</a></li><li><a href="#谈谈你对-promise-的理解" class="table-of-contents__link">谈谈你对 promise 的理解？</a></li><li><a href="#谈谈你对-async-函数的理解" class="table-of-contents__link">谈谈你对 async 函数的理解？</a></li><li><a href="#浏览器事件轮询机制谈谈完整异步代码的执行机制从浏览器到-nodejs" class="table-of-contents__link">（浏览器事件轮询机制）谈谈完整异步代码的执行机制（从浏览器到 nodejs）?</a></li><li><a href="#谈一谈继承" class="table-of-contents__link">谈一谈继承</a></li><li><a href="#谈谈callapplybind" class="table-of-contents__link">谈谈call/apply/bind</a></li><li><a href="#说一下事件委托" class="table-of-contents__link">说一下事件委托</a></li><li><a href="#谈一谈作用域链" class="table-of-contents__link">谈一谈作用域链</a></li><li><a href="#什么是执行上下文" class="table-of-contents__link">什么是执行上下文</a></li><li><a href="#谈一谈变量对象" class="table-of-contents__link">谈一谈变量对象</a></li><li><a href="#说一下事件轮询机制" class="table-of-contents__link">说一下事件轮询机制</a></li><li><a href="#说一下-进程和线程" class="table-of-contents__link">说一下 进程和线程</a></li><li><a href="#描述多态和封装" class="table-of-contents__link">描述多态和封装</a></li><li><a href="#简单描述h5新属性多线程的书写过程" class="table-of-contents__link">简单描述h5新属性多线程的书写过程</a></li><li><a href="#事件流" class="table-of-contents__link">事件流</a></li><li><a href="#单线程与异步" class="table-of-contents__link">单线程与异步</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/my-website/assets/js/runtime~main.c0f3f700.js"></script>
<script src="/my-website/assets/js/main.116eb900.js"></script>
</body>
</html>