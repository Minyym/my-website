## 渲染流程

### 总流程

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### css样式计算

#### css样式的来源

1. link引用的外部文件
2. style标签内的文件
3. 元素的 style 属性内嵌的 CSS

#### css样式内属性值标准化

- 需要将所有值转换为渲染引擎容易理解的、标准化的计算值
- 例如：2em---32px red---rgb（）

#### 计算出每个元素的具体样式

- CSS 的继承规则和层叠规则
- CSS 继承就是每个 DOM 节点都包含有父节点的样式
- UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。

### 布局阶段

1. 创建布局树
   - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
   - 而不可见的节点会被布局树忽略掉，属性包含 dispaly:none的元素也没有被包进布局树
2. 布局计算，到这里我们的每个节点都拥有了自己的样式和布局信息

### 分层

渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）

1. 拥有层叠上下文属性的元素会被提升为单独的一层。

2. 需要剪裁（clip）的地方也会被创建为图层。

   在这里我们把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域。

### 图层绘制

1. 渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表

### 栅格化操作

- 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。
- 合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512
- 然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的
- 通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

### 合成和显示

1. 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

2. 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

3. 到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

   

   ![](https://files.catbox.moe/f21slr.webp)

## V8 是如何执行一段 JavaScript 代码的

![](https://raw.githubusercontent.com/Minyym/figure-bed/master/img/202304121805464.png)
